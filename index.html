<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Volleyball Lineup Organizer V2</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }
    #court-visualization, #roster-visualization {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin: 20px 0;
    }
    .player-tile {
      display: inline-block;
      width: 100px;
      padding: 10px;
      margin: 5px;
      border: 1px solid #000;
      border-radius: 5px;
      text-align: center;
    }
    .edit-icon {
      cursor: pointer;
      margin-left: 10px;
      font-size: 16px;
    }
    #controls {
      margin: 20px 0;
    }
    button {
      padding: 10px 20px;
      margin: 5px;
      font-size: 16px;
      cursor: pointer;
    }
    #substitution-counter {
      font-size: 18px;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <h1>Volleyball Lineup Organizer V2</h1>
  <h2>Substitution Mode</h2>
  <div id="substitution-counter">Substitutions: 0</div>
  <h3>Court</h3>
  <div id="court-visualization"></div>
  <h3>Roster (Bench)</h3>
  <div id="roster-visualization"></div>
  <div id="controls">
    <button id="optimize-button">Optimize Subs</button>
    <button id="shuffle-button">Shuffle</button>
    <button id="reset-button">Reset</button>
    <button id="next-button">Next Rotation</button>
    <button id="back-button">Back Rotation</button>
  </div>

  <script>
    // Sample player data (replace with your actual data or load from a file)
    const players = [
      { id: '1', name: 'Player 1', serveReceive: 8, setting: 4, allAround: 6 },
      { id: '2', name: 'Player 2', serveReceive: 3, setting: 9, allAround: 7 },
      { id: '3', name: 'Player 3', serveReceive: 7, setting: 5, allAround: 8 },
      { id: '4', name: 'Player 4', serveReceive: 4, setting: 8, allAround: 6 },
      { id: '5', name: 'Player 5', serveReceive: 9, setting: 3, allAround: 7 },
      { id: '6', name: 'Player 6', serveReceive: 5, setting: 7, allAround: 8 },
      { id: '7', name: 'Player 7', serveReceive: 6, setting: 6, allAround: 9 },
      { id: '8', name: 'Player 8', serveReceive: 2, setting: 8, allAround: 5 },
      { id: '9', name: 'Player 9', serveReceive: 8, setting: 4, allAround: 7 },
      { id: '10', name: 'Player 10', serveReceive: 3, setting: 9, allAround: 6 },
      { id: '11', name: 'Player 11', serveReceive: 7, setting: 5, allAround: 8 },
      { id: '12', name: 'Player 12', serveReceive: 4, setting: 7, allAround: 6 }
    ];

    // Global state
    let appState = {
      players,
      pairs: [],
      lineup: { court: [], bench: [] },
      topLineups: [],
      currentLineupIndex: 0,
      currentRotation: 0,
      substitutionCount: 0
    };

    // Pair players based on serve receive and setting scores
    function pairPlayers(players) {
      const sortedBySR = [...players].sort((a, b) => b.serveReceive - a.serveReceive);
      const sortedBySetting = [...players].sort((a, b) => b.setting - a.setting);
      const sortedByAllAround = [...players].sort((a, b) => b.allAround - a.allAround);

      const avgSR = players.reduce((sum, p) => sum + p.serveReceive, 0) / players.length;
      const avgSetting = players.reduce((sum, p) => sum + p.setting, 0) / players.length;

      const pairs = [];
      const usedPlayers = new Set();

      // Pair above-average SR with below-average SR but above-average setting
      for (let srPlayer of sortedBySR) {
        if (usedPlayers.has(srPlayer.id) || srPlayer.serveReceive <= avgSR) continue;
        for (let setPlayer of sortedBySetting) {
          if (usedPlayers.has(setPlayer.id) || setPlayer.serveReceive >= avgSR || setPlayer.setting <= avgSetting) continue;
          pairs.push({ srPlayer, setPlayer, color: getUniqueColor(pairs.length) });
          usedPlayers.add(srPlayer.id);
          usedPlayers.add(setPlayer.id);
          break;
        }
      }

      // Pair remaining players to maximize SR
      const remainingPlayers = players.filter(p => !usedPlayers.has(p.id));
      const sortedRemainingBySR = [...remainingPlayers].sort((a, b) => b.serveReceive - a.serveReceive);
      for (let i = 0; i < sortedRemainingBySR.length - 1; i += 2) {
        pairs.push({
          srPlayer: sortedRemainingBySR[i],
          setPlayer: sortedRemainingBySR[i + 1],
          color: getUniqueColor(pairs.length)
        });
        usedPlayers.add(sortedRemainingBySR[i].id);
        usedPlayers.add(sortedRemainingBySR[i + 1].id);
      }

      // Handle unpaired players (highest all-around)
      const unpaired = players.filter(p => !usedPlayers.has(p.id));
      if (unpaired.length > 0) {
        unpaired.forEach(p => pairs.push({ srPlayer: p, setPlayer: null, color: 'gold' }));
      }

      return pairs;
    }

    // Get unique color for pairs
    function getUniqueColor(index) {
      const colors = ['red', 'blue', 'green', 'purple', 'orange', 'pink'];
      return index < colors.length ? colors[index] : 'gold';
    }

    // Initialize lineup after optimization
    function initializeLineup(pairs) {
      appState.lineup = { court: [], bench: [] };
      pairs.forEach(pair => {
        if (pair.setPlayer === null) { // Unpaired (gold)
          appState.lineup.court.push({ ...pair.srPlayer, color: pair.color });
        } else {
          // Place SR player in back row, setting player on bench
          appState.lineup.court.push({ ...pair.srPlayer, color: pair.color });
          appState.lineup.bench.push({ ...pair.setPlayer, color: pair.color });
        }
      });
      // Ensure unpaired players are not adjacent
      adjustLineupToAvoidAdjacentUnpaired(appState.lineup);
      appState.substitutionCount = 0;
      updateVisualizations();
    }

    // Adjust lineup to avoid adjacent unpaired players
    function adjustLineupToAvoidAdjacentUnpaired(lineup) {
      const unpaired = lineup.court.filter(p => p.color === 'gold');
      if (unpaired.length <= 1) return;
      for (let i = 0; i < lineup.court.length - 1; i++) {
        if (lineup.court[i].color === 'gold' && lineup.court[i + 1].color === 'gold') {
          const swapIndex = lineup.court.findIndex((p, idx) => idx > i + 1 && p.color !== 'gold');
          if (swapIndex !== -1) {
            [lineup.court[i + 1], lineup.court[swapIndex]] = [lineup.court[swapIndex], lineup.court[i + 1]];
          }
        }
      }
    }

    // Rotate lineup (forward or backward)
    function rotateLineup(direction = 'forward') {
      const shift = direction === 'forward' ? 1 : -1;
      appState.currentRotation += shift;
      const newCourt = rotatePositions(appState.lineup.court, shift);

      // Check for substitutions
      newCourt.forEach((player, index) => {
        const isBackRow = index >= 3; // Positions 3-5 are back row
        const pair = appState.pairs.find(p => p.srPlayer.id === player.id || (p.setPlayer && p.setPlayer.id === player.id));
        if (!pair || pair.setPlayer === null) return; // Skip unpaired

        const shouldBeSR = isBackRow;
        const currentPlayerIsSR = player.id === pair.srPlayer.id;
        if (shouldBeSR !== currentPlayerIsSR) {
          // Swap players
          const otherPlayer = currentPlayerIsSR ? pair.setPlayer : pair.srPlayer;
          newCourt[index] = { ...otherPlayer, color: pair.color };
          const benchIndex = appState.lineup.bench.findIndex(p => p.id === otherPlayer.id);
          appState.lineup.bench[benchIndex] = { ...player, color: pair.color };
          appState.substitutionCount += shift;
        }
      });

      appState.lineup.court = newCourt;
      updateVisualizations();
    }

    // Rotate court positions
    function rotatePositions(court, shift) {
      const newCourt = [...court];
      for (let i = 0; i < court.length; i++) {
        let newIndex = (i + shift) % 6;
        if (newIndex < 0) newIndex += 6;
        newCourt[newIndex] = court[i];
      }
      return newCourt;
    }

    // Store and shuffle through top 5 lineups
    function storeTopLineups(players) {
      appState.topLineups = [];
      const pairs = pairPlayers(players);
      // Generate 5 lineups (simplified: use initial pairs for now)
      for (let i = 0; i < 5; i++) {
        appState.topLineups.push({ court: [], bench: [], pairs });
      }
      appState.currentLineupIndex = 0;
      appState.pairs = pairs;
      initializeLineup(pairs);
    }

    function shuffleLineup() {
      if (appState.topLineups.length === 0) return;
      appState.currentLineupIndex = (appState.currentLineupIndex + 1) % 5;
      const lineup = appState.topLineups[appState.currentLineupIndex];
      appState.pairs = lineup.pairs;
      initializeLineup(lineup.pairs);
    }

    // Reset substitutions and pairings
    function resetSubstitutions() {
      appState.pairs = [];
      appState.lineup = { court: [], bench: [] };
      appState.topLineups = [];
      appState.currentLineupIndex = 0;
      appState.currentRotation = 0;
      appState.substitutionCount = 0;
      updateVisualizations();
    }

    // Update court and roster visualizations
    function updateVisualizations() {
      updateCourtVisualization(appState.lineup.court);
      updateRosterVisualization(appState.lineup.bench);
      document.querySelector('#substitution-counter').textContent = `Substitutions: ${appState.substitutionCount}`;
    }

    function updateCourtVisualization(court) {
      const courtDiv = document.querySelector('#court-visualization');
      courtDiv.innerHTML = '';
      court.forEach(player => {
        const tile = document.createElement('div');
        tile.className = 'player-tile';
        tile.style.backgroundColor = player.color;
        tile.textContent = player.name;
        courtDiv.appendChild(tile);
      });
    }

    function updateRosterVisualization(bench) {
      const rosterDiv = document.querySelector('#roster-visualization');
      rosterDiv.innerHTML = '';
      bench.forEach(player => {
        const tile = document.createElement('div');
        tile.className = 'player-tile';
        tile.style.backgroundColor = player.color;
        tile.textContent = player.name;

        // Add edit icon for manual reassignment
        const editIcon = document.createElement('span');
        editIcon.className = 'edit-icon';
        editIcon.textContent = '✏️';
        editIcon.addEventListener('click', () => startPairReassignment(player));
        tile.appendChild(editIcon);

        rosterDiv.appendChild(tile);
      });
    }

    // Manual pair reassignment
    function startPairReassignment(player) {
      const newPairId = prompt('Enter ID of player to pair with (or leave blank for unpaired):');
      if (newPairId === '') {
        // Make player unpaired
        appState.pairs = appState.pairs.filter(p => p.srPlayer.id !== player.id && (!p.setPlayer || p.setPlayer.id !== player.id));
        appState.pairs.push({ srPlayer: player, setPlayer: null, color: 'gold' });
      } else {
        const newPairPlayer = appState.players.find(p => p.id === newPairId);
        if (!newPairPlayer) {
          alert('Invalid player ID');
          return;
        }
        appState.pairs = appState.pairs.map(pair => {
          if (pair.srPlayer.id === player.id) {
            return { srPlayer: player, setPlayer: newPairPlayer, color: getUniqueColor(appState.pairs.indexOf(pair)) };
          }
          if (pair.setPlayer && pair.setPlayer.id === player.id) {
            return { srPlayer: newPairPlayer, setPlayer: player, color: getUniqueColor(appState.pairs.indexOf(pair)) };
          }
          if (pair.srPlayer.id === newPairPlayer.id || (pair.setPlayer && pair.setPlayer.id === newPairPlayer.id)) {
            return { srPlayer: player, setPlayer: null, color: 'gold' };
          }
          return pair;
        });
      }
      initializeLineup(appState.pairs);
    }

    // Event listeners
    document.querySelector('#optimize-button').addEventListener('click', () => storeTopLineups(appState.players));
    document.querySelector('#shuffle-button').addEventListener('click', shuffleLineup);
    document.querySelector('#reset-button').addEventListener('click', resetSubstitutions);
    document.querySelector('#next-button').addEventListener('click', () => rotateLineup('forward'));
    document.querySelector('#back-button').addEventListener('click', () => rotateLineup('backward'));

    // Initialize
    updateVisualizations();
  </script>
</body>
</html>
