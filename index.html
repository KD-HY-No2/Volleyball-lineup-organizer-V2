<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volleyball Lineup Optimizer</title>
    <meta name="description" content="Professional volleyball lineup optimization with rotational and substitutional play modes">
    <meta name="theme-color" content="#8b5cf6">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS specific -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Volleyball Optimizer">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        
        @media (max-width: 768px) {
            html, body {
                height: 100%;
                overflow-x: hidden;
            }
        }

        ::-webkit-scrollbar {
            width: 3px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .drop-zone-active {
            background-color: rgba(59, 130, 246, 0.1) !important;
            border: 2px dashed #3b82f6 !important;
        }

        .optimizing {
            background: linear-gradient(45deg, #8b5cf6, #a855f7);
            animation: pulse 2s infinite;
        }

        .star-player {
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            border-color: #ffd700 !important;
        }

        .no-sub-player {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            background: linear-gradient(135deg, #ffd700, #ffed4e) !important;
            border: 3px solid #ffd700 !important;
        }

        .sub-color-1 { background-color: #fef3c7 !important; border: 3px solid #f59e0b !important; }
        .sub-color-2 { background-color: #dcfce7 !important; border: 3px solid #22c55e !important; }
        .sub-color-3 { background-color: #dbeafe !important; border: 3px solid #3b82f6 !important; }
        .sub-color-4 { background-color: #f3e8ff !important; border: 3px solid #8b5cf6 !important; }
        .sub-color-5 { background-color: #fce7f3 !important; border: 3px solid #ec4899 !important; }
        .sub-color-6 { background-color: #fef2f2 !important; border: 3px solid #ef4444 !important; }

        .install-prompt {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            animation: slideIn 0.3s ease-out;
        }

        .substitution-counter {
            background: linear-gradient(45deg, #06b6d4, #0891b2);
            color: white;
            font-weight: bold;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes slideIn {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const VolleyballApp = () => {
            // PWA Install State
            const [deferredPrompt, setDeferredPrompt] = useState(null);
            const [showInstallPrompt, setShowInstallPrompt] = useState(false);

            // Fixed multi-team management with proper slot rotation
            const [teamSlots, setTeamSlots] = useState(() => {
                const saved = localStorage.getItem('volleyball_teamSlots');
                return saved ? JSON.parse(saved) : {
                    active: 'team1',
                    team1: { name: 'Team 1', hasData: false },
                    team2: { name: 'Team 2', hasData: false },
                    team3: { name: 'Team 3', hasData: false }
                };
            });

            // Play Mode State
            const [playMode, setPlayMode] = useState(() => 
                localStorage.getItem(`volleyball_playMode_${teamSlots.active}`) || 'rotational'
            );

            // Load data from localStorage with proper team slot support
            const loadFromStorage = (key, defaultValue) => {
                try {
                    const saved = localStorage.getItem(`${key}_${teamSlots.active}`);
                    return saved ? JSON.parse(saved) : defaultValue;
                } catch (error) {
                    console.warn(`Error loading ${key} from storage:`, error);
                    return defaultValue;
                }
            };

            // Save data to localStorage with proper team slot support
            const saveToStorage = (key, data) => {
                try {
                    localStorage.setItem(`${key}_${teamSlots.active}`, JSON.stringify(data));
                    // Mark team as having data
                    setTeamSlots(prev => {
                        const updated = {
                            ...prev,
                            [prev.active]: { ...prev[prev.active], hasData: true }
                        };
                        localStorage.setItem('volleyball_teamSlots', JSON.stringify(updated));
                        return updated;
                    });
                } catch (error) {
                    console.warn(`Error saving ${key} to storage:`, error);
                }
            };

            // Enhanced player data structure
            const [players, setPlayers] = useState(() => {
                const saved = localStorage.getItem(`volleyball_players_${teamSlots.active}`);
                if (saved) {
                    const parsedPlayers = JSON.parse(saved);
                    return parsedPlayers.map(p => ({
                        ...p,
                        serveReceive: p.serveReceive || 3,
                        setting: p.setting || 3,
                        allAround: p.allAround || 3,
                        subPair: p.subPair || null,
                        subColor: p.subColor || null,
                        isFullTime: p.isFullTime || false
                    }));
                }
                return [
                    { id: 1, name: '1', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 2, name: '2', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 3, name: '3', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 4, name: '4', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 5, name: '5', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 6, name: '6', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 7, name: '7', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 8, name: '8', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 9, name: '9', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 10, name: '10', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false }
                ];
            });

            // Enhanced substitution tracking
            const [substitutionCount, setSubstitutionCount] = useState(0);
            const [subHistory, setSubHistory] = useState([]);
            const [rotationCount, setRotationCount] = useState(0);

            const [showPlayerForm, setShowPlayerForm] = useState(false);
            const [editingPlayer, setEditingPlayer] = useState(null);
            const [teamName, setTeamName] = useState(() => loadFromStorage('volleyball_teamName', teamSlots[teamSlots.active].name));
            const [minThreshold, setMinThreshold] = useState(() => loadFromStorage('volleyball_minThreshold', 6));
            const [isOptimizing, setIsOptimizing] = useState(false);
            const [draggedPlayer, setDraggedPlayer] = useState(null);
            const [dropZone, setDropZone] = useState(null);
            const [bestLineups, setBestLineups] = useState([]);
            const [currentLineupIndex, setCurrentLineupIndex] = useState(0);

            // Enhanced form state with mode-specific attributes
            const [playerForm, setPlayerForm] = useState({
                name: '',
                defense: 3,
                serving: 3,
                serveReceive: 3,
                setting: 3,
                allAround: 3,
                active: true,
                star: false
            });

            // Court positions
            const [courtPositions, setCourtPositions] = useState(() => 
                loadFromStorage('volleyball_courtPositions', {
                    backLeft: null,
                    frontLeft: null,
                    frontMiddle: null,
                    frontRight: null,
                    backRight: null,
                    backMiddle: null,
                    bench: []
                })
            );

            // Fixed team switching with proper slot rotation
            const switchTeam = (targetSlot) => {
                // Save current team data before switching
                saveToStorage('volleyball_players', players);
                saveToStorage('volleyball_teamName', teamName);
                saveToStorage('volleyball_minThreshold', minThreshold);
                saveToStorage('volleyball_courtPositions', courtPositions);
                localStorage.setItem(`volleyball_playMode_${teamSlots.active}`, playMode);
                
                // Update team name in slots
                const currentActiveSlot = teamSlots.active;
                const updatedSlots = {
                    ...teamSlots,
                    active: targetSlot,
                    [currentActiveSlot]: { ...teamSlots[currentActiveSlot], name: teamName, hasData: true }
                };
                
                setTeamSlots(updatedSlots);
                localStorage.setItem('volleyball_teamSlots', JSON.stringify(updatedSlots));
                
                // Load target team data
                const targetTeamData = localStorage.getItem(`volleyball_players_${targetSlot}`);
                if (targetTeamData) {
                    const parsedPlayers = JSON.parse(targetTeamData);
                    setPlayers(parsedPlayers.map(p => ({
                        ...p,
                        serveReceive: p.serveReceive || 3,
                        setting: p.setting || 3,
                        allAround: p.allAround || 3,
                        subPair: p.subPair || null,
                        subColor: p.subColor || null,
                        isFullTime: p.isFullTime || false
                    })));
                } else {
                    setPlayers([
                        { id: 1, name: '1', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 2, name: '2', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 3, name: '3', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 4, name: '4', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 5, name: '5', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 6, name: '6', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 7, name: '7', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 8, name: '8', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 9, name: '9', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 10, name: '10', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false }
                    ]);
                }
                
                // Load other team-specific data
                const targetTeamName = localStorage.getItem(`volleyball_teamName_${targetSlot}`);
                setTeamName(targetTeamName ? JSON.parse(targetTeamName) : updatedSlots[targetSlot].name);
                
                const targetMinThreshold = localStorage.getItem(`volleyball_minThreshold_${targetSlot}`);
                setMinThreshold(targetMinThreshold ? JSON.parse(targetMinThreshold) : 6);
                
                const targetCourtPositions = localStorage.getItem(`volleyball_courtPositions_${targetSlot}`);
                setCourtPositions(targetCourtPositions ? JSON.parse(targetCourtPositions) : {
                    backLeft: null, frontLeft: null, frontMiddle: null,
                    frontRight: null, backRight: null, backMiddle: null, bench: []
                });
                
                const targetPlayMode = localStorage.getItem(`volleyball_playMode_${targetSlot}`);
                setPlayMode(targetPlayMode || 'rotational');
                
                // Reset optimization and substitution state
                setBestLineups([]);
                setCurrentLineupIndex(0);
                setSubstitutionCount(0);
                setSubHistory([]);
                setRotationCount(0);
            };
// Save to localStorage whenever data changes
            useEffect(() => {
                saveToStorage('volleyball_players', players);
            }, [players]);

            useEffect(() => {
                saveToStorage('volleyball_teamName', teamName);
                // Update team name in slots
                setTeamSlots(prev => {
                    const updated = {
                        ...prev,
                        [prev.active]: { ...prev[prev.active], name: teamName }
                    };
                    localStorage.setItem('volleyball_teamSlots', JSON.stringify(updated));
                    return updated;
                });
            }, [teamName]);

            useEffect(() => {
                saveToStorage('volleyball_minThreshold', minThreshold);
            }, [minThreshold]);

            useEffect(() => {
                saveToStorage('volleyball_courtPositions', courtPositions);
            }, [courtPositions]);

            useEffect(() => {
                localStorage.setItem(`volleyball_playMode_${teamSlots.active}`, playMode);
            }, [playMode, teamSlots.active]);

            // PWA Install Prompt Handling
            useEffect(() => {
                const handleBeforeInstallPrompt = (e) => {
                    e.preventDefault();
                    setDeferredPrompt(e);
                    setShowInstallPrompt(true);
                };

                const handleAppInstalled = () => {
                    setShowInstallPrompt(false);
                    setDeferredPrompt(null);
                };

                window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
                window.addEventListener('appinstalled', handleAppInstalled);

                return () => {
                    window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
                    window.removeEventListener('appinstalled', handleAppInstalled);
                };
            }, []);

            // Register Service Worker
            useEffect(() => {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('./sw.js')
                        .then((registration) => {
                            console.log('SW registered: ', registration);
                        })
                        .catch((registrationError) => {
                            console.log('SW registration failed: ', registrationError);
                        });
                }
            }, []);

            const handleInstallClick = async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    if (outcome === 'accepted') {
                        setShowInstallPrompt(false);
                    }
                    setDeferredPrompt(null);
                }
            };

            // Enhanced color assignment utility with better contrast
            const SUB_COLORS = ['sub-color-1', 'sub-color-2', 'sub-color-3', 'sub-color-4', 'sub-color-5', 'sub-color-6'];

            // Get available sub colors
            const getAvailableSubColors = () => {
                const usedColors = new Set(players.map(p => p.subColor).filter(p => p !== null));
                return SUB_COLORS.filter((_, index) => !usedColors.has(index));
            };

            // Enhanced player management functions
            const handleAddPlayer = () => {
                if (playerForm.name.trim()) {
                    const newPlayer = {
                        id: Date.now(),
                        ...playerForm,
                        subPair: null,
                        subColor: null,
                        isFullTime: false
                    };
                    setPlayers([...players, newPlayer]);
                    setPlayerForm({ 
                        name: '', 
                        defense: 3, 
                        serving: 3, 
                        serveReceive: 3, 
                        setting: 3, 
                        allAround: 3, 
                        active: true, 
                        star: false 
                    });
                    setShowPlayerForm(false);
                }
            };

            const handleEditPlayer = (player) => {
                if (draggedPlayer) return;
                setEditingPlayer(player.id);
                setPlayerForm({
                    name: player.name,
                    defense: player.defense,
                    serving: player.serving,
                    serveReceive: player.serveReceive || 3,
                    setting: player.setting || 3,
                    allAround: player.allAround || 3,
                    active: player.active,
                    star: player.star
                });
                setShowPlayerForm(true);
            };

            const handleUpdatePlayer = () => {
                setPlayers(players.map(p => 
                    p.id === editingPlayer ? { 
                        ...p, 
                        name: playerForm.name,
                        defense: playerForm.defense,
                        serving: playerForm.serving,
                        serveReceive: playerForm.serveReceive,
                        setting: playerForm.setting,
                        allAround: playerForm.allAround,
                        active: playerForm.active,
                        star: playerForm.star
                    } : p
                ));
                setEditingPlayer(null);
                setPlayerForm({ 
                    name: '', 
                    defense: 3, 
                    serving: 3, 
                    serveReceive: 3, 
                    setting: 3, 
                    allAround: 3, 
                    active: true, 
                    star: false 
                });
                setShowPlayerForm(false);
            };

            const togglePlayerActive = (id) => {
                setPlayers(players.map(p => 
                    p.id === id ? { ...p, active: !p.active } : p
                ));
            };

            const togglePlayerStar = (id) => {
                const currentStars = players.filter(p => p.star).length;
                const targetPlayer = players.find(p => p.id === id);
                
                if (!targetPlayer.star && currentStars >= 3) {
                    return;
                }
                
                setPlayers(players.map(p => 
                    p.id === id ? { ...p, star: !p.star } : p
                ));
            };

            // Enhanced substitution pairing functions with automatic color assignment
            const createSubPair = (player1Id, player2Id) => {
                const availableColors = getAvailableSubColors();
                if (availableColors.length === 0) return false;

                const colorIndex = SUB_COLORS.indexOf(availableColors[0]);

                setPlayers(prev => prev.map(p => {
                    if (p.id === player1Id || p.id === player2Id) {
                        return { 
                            ...p, 
                            subPair: p.id === player1Id ? player2Id : player1Id,
                            subColor: colorIndex,
                            isFullTime: false
                        };
                    }
                    return p;
                }));
                return true;
            };

            const removeSubPair = (playerId) => {
                const player = players.find(p => p.id === playerId);
                if (!player || !player.subPair) return;

                const pairId = player.subPair;
                setPlayers(prev => prev.map(p => {
                    if (p.id === playerId || p.id === pairId) {
                        return { ...p, subPair: null, subColor: null, isFullTime: false };
                    }
                    return p;
                }));
            };

            const changeSubColor = (playerId, newColorIndex) => {
                const player = players.find(p => p.id === playerId);
                if (!player || !player.subPair) return;

                const pairId = player.subPair;
                setPlayers(prev => prev.map(p => {
                    if (p.id === playerId || p.id === pairId) {
                        return { ...p, subColor: newColorIndex };
                    }
                    return p;
                }));
            };

            // Intelligent substitution logic - determines which player should be on court based on position
            const getOptimalPlayerForPosition = (player1, player2, isBackRow) => {
                if (!player1 || !player2) return player1 || player2;
                
                if (isBackRow) {
                    // Back row: prefer higher serve receive
                    return player1.serveReceive >= player2.serveReceive ? player1 : player2;
                } else {
                    // Front row: prefer higher setting
                    return player1.setting >= player2.setting ? player1 : player2;
                }
            };

            // Check if a position is in back row
            const isBackRowPosition = (position) => {
                return ['backLeft', 'backMiddle', 'backRight'].includes(position);
            };

            // Determine which players should be full-time (no subs) based on roster size
            const determineFullTimePlayers = (activePlayers) => {
                if (activePlayers.length <= 6) {
                    // Not enough players for any subs - all are full-time
                    return activePlayers.map(p => p.id);
                }
                
                const availableForPairing = activePlayers.length - (activePlayers.filter(p => p.star).length);
                const needFullTime = availableForPairing % 2; // Odd number means someone needs to be full-time
                
                if (needFullTime === 0) return [];
                
                // Select highest all-around rated players as full-time
                const sortedByAllAround = activePlayers
                    .filter(p => !p.star) // Stars are already marked as no-sub
                    .sort((a, b) => b.allAround - a.allAround);
                    
                return sortedByAllAround.slice(0, needFullTime).map(p => p.id);
            };

            // Export team data
            const exportData = () => {
                const data = {
                    players,
                    teamName,
                    minThreshold,
                    courtPositions,
                    playMode,
                    teamSlots,
                    exportDate: new Date().toISOString()
                };
                
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `volleyball_team_${teamName.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
            };

            // Import team data
            const handleImportData = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        if (importedData.players) setPlayers(importedData.players);
                        if (importedData.teamName) setTeamName(importedData.teamName);
                        if (importedData.minThreshold) setMinThreshold(importedData.minThreshold);
                        if (importedData.courtPositions) setCourtPositions(importedData.courtPositions);
                        if (importedData.playMode) setPlayMode(importedData.playMode);
                        if (importedData.teamSlots) setTeamSlots(importedData.teamSlots);
                        
                        alert('Team data imported successfully!');
                    } catch (error) {
                        alert('Error importing data. Please check the file format.');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            };

            // Helper function to check star player rules for rotational mode
            const checkStarRules = (positions) => {
                const courtPlayers = [
                    positions.backLeft,
                    positions.frontLeft,
                    positions.frontMiddle,
                    positions.frontRight,
                    positions.backRight,
                    positions.backMiddle
                ].filter(Boolean);

                const starsOnCourt = courtPlayers.filter(p => p.star).length;
                
                if (starsOnCourt === 0) return false;

                const starPositions = [];
                if (positions.backLeft?.star) starPositions.push(1);
                if (positions.frontLeft?.star) starPositions.push(2);
                if (positions.frontMiddle?.star) starPositions.push(3);
                if (positions.frontRight?.star) starPositions.push(4);
                if (positions.backRight?.star) starPositions.push(5);
                if (positions.backMiddle?.star) starPositions.push(6);

                for (let i = 0; i < starPositions.length; i++) {
                    for (let j = i + 1; j < starPositions.length; j++) {
                        const pos1 = starPositions[i];
                        const pos2 = starPositions[j];
                        
                        if (Math.abs(pos1 - pos2) === 1 || (pos1 === 1 && pos2 === 6) || (pos1 === 6 && pos2 === 1)) {
                            return false;
                        }
                    }
                }

                return true;
            };
// Calculate rotation strengths for rotational mode
            const calculateRotationStrengths = (positions) => {
                const rotations = [];
                let currentPositions = { ...positions };
                
                for (let i = 0; i < 10; i++) {
                    const frontRowTotal = (currentPositions.frontLeft?.defense || 0) + 
                                         (currentPositions.frontMiddle?.defense || 0) + 
                                         (currentPositions.frontRight?.defense || 0);
                    const backRowTotal = (currentPositions.backLeft?.defense || 0) + 
                                        (currentPositions.backMiddle?.defense || 0) + 
                                        (currentPositions.backRight?.defense || 0);
                    
                    rotations.push({
                        frontRowTotal,
                        backRowTotal,
                        serverRating: currentPositions.backLeft?.serving || 0,
                        rotation: i
                    });
                    
                    const newPositions = {
                        backRight: currentPositions.backMiddle,
                        frontRight: currentPositions.backRight,
                        frontMiddle: currentPositions.frontRight,
                        frontLeft: currentPositions.frontMiddle,
                        backLeft: currentPositions.frontLeft,
                        bench: [...currentPositions.bench]
                    };
                    
                    const newBench = [...currentPositions.bench];
                    if (newBench.length > 0) {
                        newBench.push(currentPositions.backLeft);
                        newPositions.backMiddle = newBench.shift();
                    } else {
                        newPositions.backMiddle = currentPositions.backLeft;
                    }
                    newPositions.bench = newBench;
                    
                    currentPositions = newPositions;
                }
                
                return rotations;
            };

            // Enhanced substitutional play optimization algorithm with proper pairing and positioning
            const optimizeSubstitutionalPlay = async () => {
                setIsOptimizing(true);
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const activePlayers = players.filter(p => p.active);
                const noSubPlayers = activePlayers.filter(p => p.star);
                
                if (activePlayers.length < 6) {
                    alert("Need at least 6 active players for optimization.");
                    setIsOptimizing(false);
                    return;
                }

                // Clear existing pairs and determine full-time players
                setPlayers(prev => prev.map(p => ({
                    ...p,
                    subPair: null,
                    subColor: null,
                    isFullTime: false
                })));

                // Determine which players should be full-time
                const fullTimePlayerIds = determineFullTimePlayers(activePlayers);
                
                // Generate optimal pairings based on complementary skills
                const pairablePlayers = activePlayers.filter(p => !p.star && !fullTimePlayerIds.includes(p.id));
                const pairings = [];
                const unpaired = [...pairablePlayers];
                
                while (unpaired.length >= 2) {
                    let bestPair = null;
                    let bestScore = -1;
                    
                    for (let i = 0; i < unpaired.length - 1; i++) {
                        for (let j = i + 1; j < unpaired.length; j++) {
                            const p1 = unpaired[i];
                            const p2 = unpaired[j];
                            
                            // Score based on complementary skills - prefer different strengths
                            const srDifference = Math.abs(p1.serveReceive - p2.serveReceive);
                            const settingDifference = Math.abs(p1.setting - p2.setting);
                            const allAroundSum = p1.allAround + p2.allAround;
                            
                            // Higher score for complementary skills
                            const pairScore = allAroundSum + (srDifference * 2) + (settingDifference * 2);
                            
                            if (pairScore > bestScore) {
                                bestScore = pairScore;
                                bestPair = [i, j];
                            }
                        }
                    }
                    
                    if (bestPair) {
                        const [i, j] = bestPair;
                        const p1 = unpaired[i];
                        const p2 = unpaired[j];
                        
                        pairings.push([p1.id, p2.id]);
                        
                        // Remove paired players (remove higher index first)
                        unpaired.splice(Math.max(i, j), 1);
                        unpaired.splice(Math.min(i, j), 1);
                    } else {
                        break;
                    }
                }
                
                // Apply the pairings with automatic color assignment
                let colorIndex = 0;
                const availableColors = getAvailableSubColors();
                
                setPlayers(prev => prev.map(p => {
                    // Mark full-time players
                    if (fullTimePlayerIds.includes(p.id)) {
                        return { ...p, isFullTime: true, subPair: null, subColor: null };
                    }
                    
                    // Apply pairings with colors
                    for (let i = 0; i < pairings.length; i++) {
                        const [id1, id2] = pairings[i];
                        if (p.id === id1 || p.id === id2) {
                            return {
                                ...p,
                                subPair: p.id === id1 ? id2 : id1,
                                subColor: i % availableColors.length,
                                isFullTime: false
                            };
                        }
                    }
                    
                    return p;
                }));

                // Now optimize starting lineup ensuring no paired players are both on court
                let bestLineup = null;
                let bestScore = -1;
                
                // Create initial lineup ensuring proper substitution pairing
                const courtPlayers = [];
                const benchPlayers = [];
                
                // Add all no-sub and full-time players to court first
                const priorityPlayers = activePlayers.filter(p => 
                    p.star || fullTimePlayerIds.includes(p.id)
                );
                courtPlayers.push(...priorityPlayers);
                
                // Add one player from each sub pair to court, other to bench
                pairings.forEach(([id1, id2]) => {
                    const p1 = activePlayers.find(p => p.id === id1);
                    const p2 = activePlayers.find(p => p.id === id2);
                    
                    if (!p1 || !p2) return;
                    
                    // Start with better serve receive player in back row position
                    const backRowPlayer = p1.serveReceive >= p2.serveReceive ? p1 : p2;
                    const frontRowPlayer = backRowPlayer === p1 ? p2 : p1;
                    
                    if (courtPlayers.length < 6) {
                        courtPlayers.push(backRowPlayer);
                        benchPlayers.push(frontRowPlayer);
                    } else {
                        benchPlayers.push(backRowPlayer, frontRowPlayer);
                    }
                });
                
                // Fill remaining court spots if needed
                const remainingPlayers = activePlayers.filter(p => 
                    !courtPlayers.includes(p) && !benchPlayers.includes(p)
                );
                courtPlayers.push(...remainingPlayers.slice(0, 6 - courtPlayers.length));
                benchPlayers.push(...remainingPlayers.slice(6 - courtPlayers.length));
                
                // Generate permutations of court positions
                const generatePermutations = (arr, current = []) => {
                    if (current.length === Math.min(6, arr.length)) {
                        return [current];
                    }
                    const perms = [];
                    for (let i = 0; i < arr.length; i++) {
                        if (!current.includes(arr[i])) {
                            const newCurrent = [...current, arr[i]];
                            perms.push(...generatePermutations(arr, newCurrent));
                        }
                    }
                    return perms;
                };
                
                const courtPermutations = generatePermutations(courtPlayers.slice(0, 6));

                for (const perm of courtPermutations.slice(0, 50)) { // Limit for performance
                    const testPositions = {
                        backLeft: perm[0] || null,
                        frontLeft: perm[1] || null,
                        frontMiddle: perm[2] || null,
                        frontRight: perm[3] || null,
                        backRight: perm[4] || null,
                        backMiddle: perm[5] || null,
                        bench: benchPlayers
                    };

                    // Verify no paired players are both on court
                    const courtPlayerIds = [
                        testPositions.backLeft?.id,
                        testPositions.frontLeft?.id,
                        testPositions.frontMiddle?.id,
                        testPositions.frontRight?.id,
                        testPositions.backRight?.id,
                        testPositions.backMiddle?.id
                    ].filter(Boolean);
                    
                    let invalidPairing = false;
                    for (const [id1, id2] of pairings) {
                        if (courtPlayerIds.includes(id1) && courtPlayerIds.includes(id2)) {
                            invalidPairing = true;
                            break;
                        }
                    }
                    
                    if (invalidPairing) continue;

                    const rotationScores = [];
                    let currentPos = { ...testPositions };
                    
                    for (let rotation = 0; rotation < 6; rotation++) {
                        const backRowSR = (currentPos.backLeft?.serveReceive || 0) + 
                                         (currentPos.backMiddle?.serveReceive || 0) + 
                                         (currentPos.backRight?.serveReceive || 0);
                        
                        const frontRowSetting = (currentPos.frontLeft?.setting || 0) + 
                                               (currentPos.frontMiddle?.setting || 0) + 
                                               (currentPos.frontRight?.setting || 0);
                        
                        rotationScores.push(backRowSR + frontRowSetting);
                        
                        // Simulate rotation
                        const newPos = {
                            backRight: currentPos.backMiddle,
                            frontRight: currentPos.backRight,
                            frontMiddle: currentPos.frontRight,
                            frontLeft: currentPos.frontMiddle,
                            backLeft: currentPos.frontLeft,
                            backMiddle: currentPos.backLeft,
                            bench: [...currentPos.bench]
                        };
                        currentPos = newPos;
                    }
                    
                    const avgScore = rotationScores.reduce((a, b) => a + b, 0) / rotationScores.length;
                    
                    if (avgScore > bestScore) {
                        bestScore = avgScore;
                        bestLineup = testPositions;
                    }
                }

                if (bestLineup) {
                    setCourtPositions(bestLineup);
                    setBestLineups([{ positions: bestLineup, score: bestScore }]);
                }
                
                setSubstitutionCount(0);
                setSubHistory([]);
                setRotationCount(0);
                setIsOptimizing(false);
            };
// Serving Priority Optimization with Star Rules
            const optimizeServingPriority = async () => {
                if (playMode === 'substitutional') {
                    optimizeSubstitutionalPlay();
                    return;
                }

                setIsOptimizing(true);
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const activePlayers = players.filter(p => p.active);
                const starPlayers = activePlayers.filter(p => p.star);
                
                if (activePlayers.length < 6) {
                    setIsOptimizing(false);
                    return;
                }

                if (starPlayers.length === 0) {
                    alert("Please select at least 1 star player to use optimization.");
                    setIsOptimizing(false);
                    return;
                }

                let eligibleServers = starPlayers.filter(p => p.serving >= 3);
                if (eligibleServers.length === 0) {
                    eligibleServers = activePlayers.filter(p => p.serving >= 3);
                }
                if (eligibleServers.length === 0) {
                    eligibleServers = [...starPlayers].sort((a, b) => b.serving - a.serving).slice(0, 1);
                }
                
                const firstServer = eligibleServers.sort((a, b) => a.defense - b.defense)[0];
                const remainingPlayers = activePlayers.filter(p => p.id !== firstServer.id);
                const topServers = remainingPlayers.sort((a, b) => b.serving - a.serving).slice(0, 5);
                const benchPlayers = remainingPlayers.filter(p => !topServers.some(ts => ts.id === p.id))
                    .sort((a, b) => b.defense - a.defense);

                let allLineups = [];

                const generatePermutations = (arr, current = []) => {
                    if (current.length === arr.length) {
                        return [current];
                    }
                    const perms = [];
                    for (let i = 0; i < arr.length; i++) {
                        if (!current.includes(arr[i])) {
                            const newCurrent = [...current, arr[i]];
                            perms.push(...generatePermutations(arr, newCurrent));
                        }
                    }
                    return perms;
                };

                const serverPermutations = generatePermutations(topServers);

                for (const perm of serverPermutations) {
                    const testPositions = {
                        backLeft: firstServer,
                        frontLeft: perm[0],
                        frontMiddle: perm[1],
                        frontRight: perm[2],
                        backRight: perm[3],
                        backMiddle: perm[4],
                        bench: benchPlayers
                    };

                    if (!checkStarRules(testPositions)) continue;

                    const rotations = calculateRotationStrengths(testPositions);
                    
                    let aboveThresholdCount = 0;
                    let totalDefense = 0;
                    let servingScore = 0;
                    let starBonus = 0;

                    rotations.forEach((rotation, index) => {
                        if (rotation.frontRowTotal >= minThreshold && rotation.backRowTotal >= minThreshold) {
                            aboveThresholdCount++;
                        }
                        totalDefense += rotation.frontRowTotal + rotation.backRowTotal;
                        
                        const rotationWeight = Math.max(1, 20 - (index * 2));
                        servingScore += rotation.serverRating * rotationWeight;

                        let currentPos = { ...testPositions };
                        for (let r = 0; r < index; r++) {
                            const newPos = {
                                backRight: currentPos.backMiddle,
                                frontRight: currentPos.backRight,
                                frontMiddle: currentPos.frontRight,
                                frontLeft: currentPos.frontMiddle,
                                backLeft: currentPos.frontLeft,
                                bench: [...currentPos.bench]
                            };
                            const newBench = [...currentPos.bench];
                            if (newBench.length > 0) {
                                newBench.push(currentPos.backLeft);
                                newPos.backMiddle = newBench.shift();
                            } else {
                                newPos.backMiddle = currentPos.backLeft;
                            }
                            newPos.bench = newBench;
                            currentPos = newPos;
                        }

                        const courtPlayers = [currentPos.backLeft, currentPos.frontLeft, currentPos.frontMiddle,
                                            currentPos.frontRight, currentPos.backRight, currentPos.backMiddle];
                        const starsOnCourt = courtPlayers.filter(p => p && p.star).length;
                        if (starsOnCourt >= 2) starBonus += 3;
                    });

                    const avgDefense = totalDefense / rotations.length;
                    const thresholdPercent = aboveThresholdCount / rotations.length;
                    const score = (servingScore * 1.0) + (avgDefense * 2) + (thresholdPercent * 50) + starBonus;

                    allLineups.push({
                        positions: testPositions,
                        score: score,
                        thresholdPercent: thresholdPercent,
                        avgDefense: avgDefense,
                        servingScore: servingScore,
                        starBonus: starBonus
                    });
                }

                allLineups.sort((a, b) => b.score - a.score);
                const topLineups = allLineups.slice(0, 10);
                
                setBestLineups(topLineups);
                setCurrentLineupIndex(0);

                if (topLineups.length > 0) {
                    setCourtPositions(topLineups[0].positions);
                }
                
                setIsOptimizing(false);
            };

            const shuffleStandardPlay = () => {
                if (bestLineups.length === 0) return;
                
                const nextIndex = (currentLineupIndex + 1) % bestLineups.length;
                setCurrentLineupIndex(nextIndex);
                setCourtPositions(bestLineups[nextIndex].positions);
            };

            const autoArrangePlayers = () => {
                const activePlayers = players.filter(p => p.active);
                if (activePlayers.length < 6) return;

                const newPositions = {
                    backLeft: activePlayers.find(p => p.name === '1') || activePlayers[0],
                    frontLeft: activePlayers.find(p => p.name === '2') || activePlayers[1],
                    frontMiddle: activePlayers.find(p => p.name === '3') || activePlayers[2],
                    frontRight: activePlayers.find(p => p.name === '4') || activePlayers[3],
                    backRight: activePlayers.find(p => p.name === '5') || activePlayers[4],
                    backMiddle: activePlayers.find(p => p.name === '6') || activePlayers[5],
                    bench: activePlayers.slice(6)
                };
                setCourtPositions(newPositions);
                
                // Reset substitution tracking
                if (playMode === 'substitutional') {
                    setSubstitutionCount(0);
                    setSubHistory([]);
                    setRotationCount(0);
                }
            };

            const rotateForward = () => {
                if (playMode === 'substitutional') {
                    rotateWithSubstitutions('forward');
                    return;
                }

                const courtPlayers = [
                    courtPositions.backLeft,
                    courtPositions.backMiddle,
                    courtPositions.backRight,
                    courtPositions.frontLeft,
                    courtPositions.frontMiddle,
                    courtPositions.frontRight
                ].filter(Boolean);
                
                if (courtPlayers.length < 6) return;

                const newPositions = {
                    backRight: courtPositions.backMiddle,
                    frontRight: courtPositions.backRight,
                    frontMiddle: courtPositions.frontRight,
                    frontLeft: courtPositions.frontMiddle,
                    backLeft: courtPositions.frontLeft,
                    bench: [...courtPositions.bench]
                };

                const newBench = [...courtPositions.bench];
                newBench.push(courtPositions.backLeft);
                
                if (newBench.length > 0) {
                    newPositions.backMiddle = newBench.shift();
                }
                
                newPositions.bench = newBench;
                setCourtPositions(newPositions);
            };

            const rotateBackward = () => {
                if (playMode === 'substitutional') {
                    rotateWithSubstitutions('backward');
                    return;
                }

                const courtPlayers = [
                    courtPositions.backLeft,
                    courtPositions.backMiddle,
                    courtPositions.backRight,
                    courtPositions.frontLeft,
                    courtPositions.frontMiddle,
                    courtPositions.frontRight
                ].filter(Boolean);
                
                if (courtPlayers.length < 6) return;

                const newPositions = {
                    frontLeft: courtPositions.backLeft,
                    frontMiddle: courtPositions.frontLeft,
                    frontRight: courtPositions.frontMiddle,
                    backRight: courtPositions.frontRight,
                    backMiddle: courtPositions.backRight,
                    bench: [...courtPositions.bench]
                };

                const newBench = [...courtPositions.bench];
                newBench.unshift(courtPositions.backMiddle);
                
                if (newBench.length > 0) {
                    newPositions.backLeft = newBench.pop();
                }
                
                newPositions.bench = newBench;
                setCourtPositions(newPositions);
            };

            // Drag and Drop handlers
            const handleDragStart = (e, player) => {
                setDraggedPlayer(player);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDragEnter = (e, zone) => {
                e.preventDefault();
                setDropZone(zone);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                setDropZone(null);
            };

            const handleDrop = (e, targetPosition) => {
                e.preventDefault();
                if (!draggedPlayer) return;

                const newPositions = { ...courtPositions };
                
                let currentPosition = null;
                Object.keys(newPositions).forEach(pos => {
                    if (pos === 'bench') {
                        const benchIndex = newPositions[pos].findIndex(p => p.id === draggedPlayer.id);
                        if (benchIndex >= 0) {
                            currentPosition = { type: 'bench', index: benchIndex };
                        }
                    } else if (newPositions[pos] && newPositions[pos].id === draggedPlayer.id) {
                        currentPosition = { type: 'court', position: pos };
                    }
                });

                if (currentPosition) {
                    if (currentPosition.type === 'bench') {
                        newPositions.bench.splice(currentPosition.index, 1);
                    } else {
                        newPositions[currentPosition.position] = null;
                    }
                }

                if (targetPosition === 'bench') {
                    newPositions.bench.push(draggedPlayer);
                } else if (targetPosition.startsWith('bench-')) {
                    const index = parseInt(targetPosition.split('-')[1]);
                    newPositions.bench.splice(index, 0, draggedPlayer);
                } else {
                    if (newPositions[targetPosition]) {
                        if (currentPosition && currentPosition.type === 'court') {
                            newPositions[currentPosition.position] = newPositions[targetPosition];
                        } else if (currentPosition && currentPosition.type === 'bench') {
                            newPositions.bench.splice(currentPosition.index, 0, newPositions[targetPosition]);
                        }
                    }
                    newPositions[targetPosition] = draggedPlayer;
                }

                setCourtPositions(newPositions);
                setDraggedPlayer(null);
                setDropZone(null);
            };

// Calculate current strengths based on play mode
            const calculateCurrentStrengths = () => {
                if (playMode === 'rotational') {
                    return calculateRotationStrengths(courtPositions).slice(0, 6);
                } else {
                    // For substitutional mode, calculate serve receive and setting strengths
                    const rotations = [];
                    let currentPositions = { ...courtPositions };
                    
                    for (let i = 0; i < 6; i++) {
                        const backRowSR = (currentPositions.backLeft?.serveReceive || 0) + 
                                         (currentPositions.backMiddle?.serveReceive || 0) + 
                                         (currentPositions.backRight?.serveReceive || 0);
                        
                        const frontRowSetting = (currentPositions.frontLeft?.setting || 0) + 
                                               (currentPositions.frontMiddle?.setting || 0) + 
                                               (currentPositions.frontRight?.setting || 0);
                        
                        rotations.push({
                            backRowSR,
                            frontRowSetting,
                            serverRating: currentPositions.backLeft?.serving || 0,
                            rotation: i
                        });
                        
                        const newPositions = {
                            backRight: currentPositions.backMiddle,
                            frontRight: currentPositions.backRight,
                            frontMiddle: currentPositions.frontRight,
                            frontLeft: currentPositions.frontMiddle,
                            backLeft: currentPositions.frontLeft,
                            backMiddle: currentPositions.backLeft,
                            bench: [...currentPositions.bench]
                        };
                        currentPositions = newPositions;
                    }
                    
                    return rotations;
                }
            };

            const currentStrengths = calculateCurrentStrengths();

            const PlayerTile = ({ player, position, isOnCourt, benchIndex }) => {
                const subColorClass = player.subColor !== null ? SUB_COLORS[player.subColor] : '';
                const isNoSub = (playMode === 'substitutional' && player.star) || player.isFullTime;
                
                return React.createElement('div', {
                    className: `p-3 rounded-lg shadow-md cursor-pointer transition-all ${
                        player.active 
                            ? (isOnCourt ? 'bg-blue-100 border-2 border-blue-500' : 'bg-green-100 border-2 border-green-400')
                            : 'bg-gray-200 border-2 border-gray-300'
                    } ${isNoSub ? 'no-sub-player' : subColorClass} ${
                        playMode === 'rotational' && player.star ? 'star-player' : ''
                    } ${draggedPlayer && draggedPlayer.id === player.id ? 'dragging' : ''}`,
                    draggable: true,
                    onDragStart: (e) => handleDragStart(e, player),
                    onClick: () => handleEditPlayer(player)
                },
                    React.createElement('div', { className: "flex items-center justify-between" },
                        React.createElement('div', { className: "font-semibold text-sm" }, player.name),
                        React.createElement('div', { className: "flex gap-1" },
                            (playMode === 'rotational' && player.star) && React.createElement('span', { className: "text-yellow-500 text-xs" }, '⭐'),
                            (playMode === 'substitutional' && (player.star || player.isFullTime)) && React.createElement('span', { className: "text-yellow-500 text-xs" }, '⭐'),
                            (playMode === 'substitutional' && player.subPair) && React.createElement('span', { className: "text-blue-500 text-xs" }, '🔗')
                        )
                    ),
                    position && React.createElement('div', { className: "text-xs text-gray-600 mt-1" }, position)
                );
            };

            const DropZone = ({ position, currentPlayer, label }) => (
                React.createElement('div', {
                    className: `h-16 border-2 border-dashed rounded-lg flex items-center justify-center transition-all ${
                        dropZone === position ? 'drop-zone-active' : 'border-gray-300'
                    }`,
                    onDragOver: handleDragOver,
                    onDragEnter: (e) => handleDragEnter(e, position),
                    onDragLeave: handleDragLeave,
                    onDrop: (e) => handleDrop(e, position)
                },
                    currentPlayer ? 
                        React.createElement(PlayerTile, { player: currentPlayer, position: label, isOnCourt: true }) :
                        React.createElement('span', { className: "text-xs text-gray-400" }, "Empty")
                )
            );

            const CourtDisplay = () => (
                React.createElement('div', { className: "bg-orange-50 border-2 border-orange-300 rounded-lg p-4 mb-6" },
                    React.createElement('div', { className: "text-center text-sm font-semibold mb-4 text-orange-800" },
                        `${teamName} - Court Layout (${playMode.charAt(0).toUpperCase() + playMode.slice(1)} Mode)`
                    ),
                    
                    // Substitution Counter for substitutional mode
                    playMode === 'substitutional' && (
                        React.createElement('div', { className: "mb-4 p-2 substitution-counter text-center text-sm" },
                            `Substitutions: ${substitutionCount} | Rotations: ${rotationCount}`
                        )
                    ),
                    
                    // Current rotation strengths
                    currentStrengths.length > 0 && (
                        React.createElement('div', { className: "mb-4 p-3 bg-white rounded-lg border" },
                            React.createElement('div', { className: "text-xs font-semibold mb-2 text-center" }, 
                                playMode === 'rotational' 
                                    ? `Row Totals (Defense) - Min: ${minThreshold}`
                                    : "Row Totals (SR: Serve Receive, Set: Setting)"
                            ),
                            React.createElement('div', { className: "flex justify-between text-xs mb-2" },
                                playMode === 'rotational' ? (
                                    React.createElement(React.Fragment, {},
                                        React.createElement('div', {}, 
                                            `Front: ${currentStrengths[0]?.frontRowTotal || 0}`,
                                            React.createElement('span', { 
                                                className: `ml-1 ${(currentStrengths[0]?.frontRowTotal || 0) >= minThreshold ? 'text-green-600' : 'text-red-600'}`
                                            }, (currentStrengths[0]?.frontRowTotal || 0) >= minThreshold ? '✓' : '✗')
                                        ),
                                        React.createElement('div', {}, 
                                            `Back: ${currentStrengths[0]?.backRowTotal || 0}`,
                                            React.createElement('span', { 
                                                className: `ml-1 ${(currentStrengths[0]?.backRowTotal || 0) >= minThreshold ? 'text-green-600' : 'text-red-600'}`
                                            }, (currentStrengths[0]?.backRowTotal || 0) >= minThreshold ? '✓' : '✗')
                                        )
                                    )
                                ) : (
                                    React.createElement(React.Fragment, {},
                                        React.createElement('div', {}, `Back SR: ${currentStrengths[0]?.backRowSR || 0}`),
                                        React.createElement('div', {}, `Front Set: ${currentStrengths[0]?.frontRowSetting || 0}`)
                                    )
                                )
                            ),
                            bestLineups.length > 0 && (
                                React.createElement('div', { className: "text-xs text-center text-gray-600" },
                                    `Lineup ${currentLineupIndex + 1} of ${bestLineups.length} best options`
                                )
                            )
                        )
                    ),

                    // Back Row (20 ft line)
                    React.createElement('div', { className: "border-b-2 border-dashed border-orange-400 pb-3 mb-3" },
                        React.createElement('div', { className: "text-xs text-center mb-2 text-orange-700" }, "Back Row (20 ft)"),
                        React.createElement('div', { className: "grid grid-cols-3 gap-2" },
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-xs mb-1" }, "Left (Serve)"),
                                React.createElement(DropZone, { 
                                    position: "backLeft", 
                                    currentPlayer: courtPositions.backLeft, 
                                    label: "BL" 
                                })
                            ),
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-xs mb-1" }, "Middle"),
                                React.createElement(DropZone, { 
                                    position: "backMiddle", 
                                    currentPlayer: courtPositions.backMiddle, 
                                    label: "BM" 
                                })
                            ),
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-xs mb-1" }, "Right"),
                                React.createElement(DropZone, { 
                                    position: "backRight", 
                                    currentPlayer: courtPositions.backRight, 
                                    label: "BR" 
                                })
                            )
                        )
                    ),

                    // Front Row (10 ft line)
                    React.createElement('div', { className: "border-b-2 border-dashed border-orange-400 pb-3 mb-3" },
                        React.createElement('div', { className: "text-xs text-center mb-2 text-orange-700" }, "Front Row (10 ft)"),
                        React.createElement('div', { className: "grid grid-cols-3 gap-2" },
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-xs mb-1" }, "Left"),
                                React.createElement(DropZone, { 
                                    position: "frontLeft", 
                                    currentPlayer: courtPositions.frontLeft, 
                                    label: "FL" 
                                })
                            ),
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-xs mb-1" }, "Middle"),
                                React.createElement(DropZone, { 
                                    position: "frontMiddle", 
                                    currentPlayer: courtPositions.frontMiddle, 
                                    label: "FM" 
                                })
                            ),
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-xs mb-1" }, "Right"),
                                React.createElement(DropZone, { 
                                    position: "frontRight", 
                                    currentPlayer: courtPositions.frontRight, 
                                    label: "FR" 
                                })
                            )
                        )
                    ),

                    // Net
                    React.createElement('div', { className: "w-full h-2 bg-black mb-4 rounded" }),

                    // Rotation Controls
                    React.createElement('div', { className: "flex justify-center gap-4 mb-4" },
                        React.createElement('button', {
                            onClick: rotateBackward,
                            className: "flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed",
                            disabled: [courtPositions.backLeft, courtPositions.backMiddle, courtPositions.backRight, courtPositions.frontLeft, courtPositions.frontMiddle, courtPositions.frontRight].filter(Boolean).length < 6
                        },
                            "⟲ Previous"
                        ),
                        React.createElement('button', {
                            onClick: rotateForward,
                            className: "flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed",
                            disabled: [courtPositions.backLeft, courtPositions.backMiddle, courtPositions.backRight, courtPositions.frontLeft, courtPositions.frontMiddle, courtPositions.frontRight].filter(Boolean).length < 6
                        },
                            "Next ⟳"
                        )
                    )
                )
            );

            const BenchDisplay = () => (
                React.createElement('div', { 
                    className: "bg-green-50 border-2 border-green-300 rounded-lg p-4 mb-6",
                    onDragOver: handleDragOver,
                    onDragEnter: (e) => handleDragEnter(e, 'bench'),
                    onDragLeave: handleDragLeave,
                    onDrop: (e) => handleDrop(e, 'bench')
                },
                    React.createElement('div', { className: "text-center text-sm font-semibold mb-3 text-green-800" },
                        playMode === 'substitutional' 
                            ? "Bench Players (Available for substitution)"
                            : "Bench Players (Next to rotate in at bottom)"
                    ),
                    React.createElement('div', { className: "space-y-2" },
                        courtPositions.bench.map((player, index) => (
                            React.createElement('div', { key: player.id, className: "flex items-center gap-2" },
                                React.createElement('span', { className: "text-xs w-6 text-center" }, 
                                    playMode === 'rotational' ? courtPositions.bench.length - index : index + 1
                                ),
                                React.createElement(PlayerTile, { player: player, isOnCourt: false, benchIndex: index })
                            )
                        )),
                        courtPositions.bench.length === 0 && (
                            React.createElement('div', { className: "text-center text-gray-500 text-sm" }, "No bench players")
                        )
                    )
                )
            );
return React.createElement('div', { className: "max-w-md mx-auto bg-white min-h-screen p-4" },
                // PWA Install Prompt
                showInstallPrompt && (
                    React.createElement('div', { className: "install-prompt mb-4 p-4 text-white rounded-lg flex items-center justify-between" },
                        React.createElement('div', {},
                            React.createElement('div', { className: "font-semibold text-sm" }, "Install Volleyball App"),
                            React.createElement('div', { className: "text-xs opacity-90" }, "Add to home screen for offline use")
                        ),
                        React.createElement('div', { className: "flex gap-2" },
                            React.createElement('button', {
                                onClick: () => setShowInstallPrompt(false),
                                className: "px-3 py-1 bg-white bg-opacity-20 rounded text-xs"
                            }, "Later"),
                            React.createElement('button', {
                                onClick: handleInstallClick,
                                className: "px-3 py-1 bg-white text-purple-600 rounded text-xs font-semibold"
                            }, "Install")
                        )
                    )
                ),

                // Header with fixed team switcher
                React.createElement('div', { className: "mb-6" },
                    React.createElement('div', { className: "flex items-center justify-between mb-2" },
                        React.createElement('input', {
                            type: "text",
                            value: teamName,
                            onChange: (e) => setTeamName(e.target.value),
                            className: "text-lg font-bold bg-transparent border-b-2 border-gray-300 focus:border-blue-500 outline-none"
                        }),
                        React.createElement('div', { className: "flex gap-2" },
                            React.createElement('button', { 
                                onClick: exportData,
                                className: "p-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600",
                                title: "Export team data"
                            },
                                "💾"
                            ),
                            React.createElement('label', { 
                                className: "p-2 bg-green-500 text-white rounded-lg hover:bg-green-600 cursor-pointer",
                                title: "Import team data"
                            },
                                "📂",
                                React.createElement('input', {
                                    type: "file",
                                    accept: ".json",
                                    onChange: handleImportData,
                                    className: "hidden"
                                })
                            )
                        )
                    ),
                    
                    // Fixed Team Switcher
                    React.createElement('div', { className: "flex gap-2" },
                        ['team1', 'team2', 'team3'].filter(slot => slot !== teamSlots.active).map(slot => (
                            React.createElement('button', {
                                key: slot,
                                onClick: () => switchTeam(slot),
                                className: `flex-1 py-2 px-3 rounded text-sm font-medium transition-colors bg-gray-100 border border-gray-300 text-gray-700 hover:bg-gray-200`
                            }, teamSlots[slot].name)
                        ))
                    )
                ),

                // Play Mode Toggle
                React.createElement('div', { className: "mb-4 p-3 bg-gray-50 rounded-lg" },
                    React.createElement('div', { className: "text-sm font-medium mb-2" }, "Play Mode"),
                    React.createElement('div', { className: "flex gap-2" },
                        React.createElement('button', {
                            onClick: () => setPlayMode('rotational'),
                            className: `flex-1 py-2 px-3 rounded text-sm font-medium transition-colors ${
                                playMode === 'rotational' 
                                    ? 'bg-blue-500 text-white' 
                                    : 'bg-white border border-gray-300 text-gray-700 hover:bg-gray-50'
                            }`
                        }, "Rotational"),
                        React.createElement('button', {
                            onClick: () => setPlayMode('substitutional'),
                            className: `flex-1 py-2 px-3 rounded text-sm font-medium transition-colors ${
                                playMode === 'substitutional' 
                                    ? 'bg-green-500 text-white' 
                                    : 'bg-white border border-gray-300 text-gray-700 hover:bg-gray-50'
                            }`
                        }, "Substitutional")
                    )
                ),

                // Mode-specific info panel
                playMode === 'rotational' ? (
                    React.createElement('div', { className: "mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg" },
                        React.createElement('div', { className: "text-sm font-medium text-yellow-800 mb-1" },
                            `Star Players: ${players.filter(p => p.star).length}/3`
                        ),
                        React.createElement('div', { className: "text-xs text-yellow-700" },
                            "⭐ Select up to 3 star players for rotational optimization. Algorithms ensure 1+ star always on court and prevent adjacent positioning."
                        )
                    )
                ) : (
                    React.createElement('div', { className: "mb-4 p-3 bg-green-50 border border-green-200 rounded-lg" },
                        React.createElement('div', { className: "text-sm font-medium text-green-800 mb-1" },
                            "Substitutional Play Mode"
                        ),
                        React.createElement('div', { className: "text-xs text-green-700 mb-2" },
                            "⭐ Gold tiles = no substitution partner. Matching colors = paired for substitutions."
                        ),
                        React.createElement('div', { className: "text-xs text-green-600" },
                            `No-Sub Players: ${players.filter(p => p.star || p.isFullTime).length} | Sub Pairs: ${Math.floor(players.filter(p => p.subPair).length / 2)}`
                        )
                    )
                ),

                // Court Display
                React.createElement(CourtDisplay),
                
                // Bench Display
                React.createElement(BenchDisplay),

                // Optimization Controls
                React.createElement('div', { className: "mb-4 p-4 bg-gray-50 rounded-lg" },
                    playMode === 'rotational' && (
                        React.createElement('div', { className: "mb-3" },
                            React.createElement('label', { className: "block text-sm font-medium mb-1" }, 
                                `Minimum Row Total: ${minThreshold}`
                            ),
                            React.createElement('input', {
                                type: "range",
                                min: "3",
                                max: "15",
                                value: minThreshold,
                                onChange: (e) => setMinThreshold(parseInt(e.target.value)),
                                className: "w-full"
                            }),
                            React.createElement('div', { className: "flex justify-between text-xs text-gray-500 mt-1" },
                                React.createElement('span', {}, "3"),
                                React.createElement('span', {}, "15")
                            )
                        )
                    ),
                    React.createElement('div', { className: "flex gap-2" },
                        React.createElement('button', {
                            onClick: optimizeStandardPlay,
                            className: `flex-1 p-3 text-white rounded-lg transition-colors ${
                                isOptimizing ? 'optimizing cursor-not-allowed' : 
                                playMode === 'rotational' ? 'bg-purple-500 hover:bg-purple-600' : 'bg-green-500 hover:bg-green-600'
                            }`,
                            disabled: isOptimizing || players.filter(p => p.active).length < 6
                        },
                            isOptimizing ? "Optimizing..." : 
                            playMode === 'rotational' ? "🎯 Standard Play" : "🎯 Optimize Subs"
                        ),
                        playMode === 'rotational' && (
                            React.createElement('button', {
                                onClick: optimizeServingPriority,
                                className: `flex-1 p-3 text-white rounded-lg transition-colors ${
                                    isOptimizing ? 'optimizing cursor-not-allowed' : 'bg-orange-500 hover:bg-orange-600'
                                }`,
                                disabled: isOptimizing || players.filter(p => p.active).length < 6
                            },
                                isOptimizing ? "Optimizing..." : "⚡ Serving Priority"
                            )
                        ),
                        React.createElement('button', {
                            onClick: shuffleStandardPlay,
                            className: "px-3 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors disabled:bg-gray-400",
                            disabled: bestLineups.length === 0,
                            title: "Shuffle through best lineups"
                        },
                            "🔀"
                        )
                    ),
                    React.createElement('div', { className: "flex gap-2 mt-2" },
                        React.createElement('button', {
                            onClick: autoArrangePlayers,
                            className: "flex-1 p-3 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition-colors",
                            disabled: players.filter(p => p.active).length < 6
                        },
                            "📋 Basic Setup"
                        )
                    )
                ),

                // Players List
                React.createElement('div', { className: "mb-6" },
                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                        React.createElement('h2', { className: "text-lg font-semibold" }, `Team Roster (${players.length}/12)`),
                        React.createElement('button', {
                            onClick: () => setShowPlayerForm(true),
                            className: "flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
                        },
                            "+ Add Player"
                        )
                    ),
                    
                    React.createElement('div', { className: "space-y-2" },
                        players.map(player => {
                            const subColorClass = player.subColor !== null ? SUB_COLORS[player.subColor] : '';
                            const isNoSub = (playMode === 'substitutional' && player.star) || player.isFullTime;
                            const subPartner = player.subPair ? players.find(p => p.id === player.subPair) : null;
                            
                            return React.createElement('div', { 
                                key: player.id, 
                                className: `flex items-center gap-2 p-2 rounded-lg transition-all ${
                                    isNoSub ? 'no-sub-player' : subColorClass || 'bg-white'
                                } ${!player.active ? 'opacity-50' : ''}`
                            },
                                React.createElement('button', {
                                    onClick: () => togglePlayerActive(player.id),
                                    className: `w-4 h-4 rounded border-2 ${
                                        player.active ? 'bg-green-500 border-green-500' : 'border-gray-300'
                                    }`
                                }),
                                React.createElement('button', {
                                    onClick: () => togglePlayerStar(player.id),
                                    className: `w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                                        player.star ? 'bg-yellow-400 border-yellow-500' : 'border-gray-300 hover:border-yellow-400'
                                    }`,
                                    title: playMode === 'rotational' ? 'Star Player' : 'No Substitution Partner'
                                },
                                    React.createElement('span', { className: "text-xs" }, 
                                        player.star ? '⭐' : '☆'
                                    )
                                ),
                                React.createElement('div', { 
                                    className: "flex-1 cursor-pointer",
                                    onClick: () => handleEditPlayer(player)
                                },
                                    React.createElement('div', { className: "flex items-center justify-between" },
                                        React.createElement('div', { className: "font-semibold text-sm" }, player.name),
                                        React.createElement('div', { className: "flex gap-1" },
                                            subPartner && React.createElement('span', { 
                                                className: "text-xs text-blue-600",
                                                title: `Paired with ${subPartner.name}`
                                            }, '🔗'),
                                            player.isFullTime && React.createElement('span', { 
                                                className: "text-xs text-yellow-600",
                                                title: "Full-time player (no substitutions)"
                                            }, '⭐')
                                        )
                                    ),
                                    React.createElement('div', { className: "text-xs text-gray-600" },
                                        playMode === 'rotational' 
                                            ? `D:${player.defense} S:${player.serving}`
                                            : `S:${player.serving} SR:${player.serveReceive} Set:${player.setting} AA:${player.allAround}`
                                    )
                                ),
                                playMode === 'substitutional' && (
                                    React.createElement('div', { className: "flex gap-1" },
                                        // Color change buttons for sub pairs
                                        !isNoSub && player.subPair && SUB_COLORS.map((colorClass, index) => (
                                            React.createElement('button', {
                                                key: index,
                                                onClick: () => changeSubColor(player.id, index),
                                                className: `w-4 h-4 rounded border ${colorClass} ${
                                                    player.subColor === index ? 'border-2 border-black' : 'border-gray-400'
                                                }`,
                                                title: `Change to color ${index + 1}`
                                            })
                                        )),
                                        // Unpair button
                                        !isNoSub && player.subPair && (
                                            React.createElement('button', {
                                                onClick: () => removeSubPair(player.id),
                                                className: "w-4 h-4 bg-red-500 text-white rounded text-xs flex items-center justify-center",
                                                title: "Remove substitution pairing"
                                            }, "×")
                                        )
                                    )
                                )
                            );
                        })
                    )
                ),
            
