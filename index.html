<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volleyball Lineup Optimizer</title>
    <meta name="description" content="Professional volleyball lineup optimization with rotational and substitutional play modes">
    <meta name="theme-color" content="#8b5cf6">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS specific -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Volleyball Optimizer">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        
        @media (max-width: 768px) {
            html, body {
                height: 100%;
                overflow-x: hidden;
            }
        }

        ::-webkit-scrollbar {
            width: 3px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .drop-zone-active {
            background-color: rgba(59, 130, 246, 0.1) !important;
            border: 2px dashed #3b82f6 !important;
        }

        .optimizing {
            background: linear-gradient(45deg, #8b5cf6, #a855f7);
            animation: pulse 2s infinite;
        }

        .star-player {
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            border-color: #ffd700 !important;
        }

        .no-sub-player {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            background: linear-gradient(135deg, #ffd700, #ffed4e) !important;
            border: 3px solid #ffd700 !important;
        }

        .sub-color-1 { background-color: #fef3c7 !important; border: 3px solid #f59e0b !important; }
        .sub-color-2 { background-color: #dcfce7 !important; border: 3px solid #22c55e !important; }
        .sub-color-3 { background-color: #dbeafe !important; border: 3px solid #3b82f6 !important; }
        .sub-color-4 { background-color: #f3e8ff !important; border: 3px solid #8b5cf6 !important; }
        .sub-color-5 { background-color: #fce7f3 !important; border: 3px solid #ec4899 !important; }
        .sub-color-6 { background-color: #fef2f2 !important; border: 3px solid #ef4444 !important; }

        .install-prompt {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            animation: slideIn 0.3s ease-out;
        }

        .substitution-counter {
            background: linear-gradient(45deg, #06b6d4, #0891b2);
            color: white;
            font-weight: bold;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes slideIn {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .cursor-move {
    cursor: move;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

.cursor-move:active {
    opacity: 0.7;
    transform: scale(0.95);
}

@media (hover: none) and (pointer: coarse) {
    .cursor-move {
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
    }
}
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const VolleyballApp = () => {
            // PWA Install State
            const [deferredPrompt, setDeferredPrompt] = useState(null);
            const [showInstallPrompt, setShowInstallPrompt] = useState(false);

            // Fixed multi-team management with proper slot rotation
            const [teamSlots, setTeamSlots] = useState(() => {
                const saved = localStorage.getItem('volleyball_teamSlots');
                return saved ? JSON.parse(saved) : {
                    active: 'team1',
                    team1: { name: 'Team 1', hasData: false },
                    team2: { name: 'Team 2', hasData: false },
                    team3: { name: 'Team 3', hasData: false }
                };
            });

            // Play Mode State
            const [playMode, setPlayMode] = useState(() => 
                localStorage.getItem(`volleyball_playMode_${teamSlots.active}`) || 'rotational'
            );

            // Load data from localStorage with proper team slot support
            const loadFromStorage = (key, defaultValue) => {
                try {
                    const saved = localStorage.getItem(`${key}_${teamSlots.active}`);
                    return saved ? JSON.parse(saved) : defaultValue;
                } catch (error) {
                    console.warn(`Error loading ${key} from storage:`, error);
                    return defaultValue;
                }
            };

            // Save data to localStorage with proper team slot support
            const saveToStorage = (key, data) => {
                try {
                    localStorage.setItem(`${key}_${teamSlots.active}`, JSON.stringify(data));
                    // Mark team as having data
                    setTeamSlots(prev => {
                        const updated = {
                            ...prev,
                            [prev.active]: { ...prev[prev.active], hasData: true }
                        };
                        localStorage.setItem('volleyball_teamSlots', JSON.stringify(updated));
                        return updated;
                    });
                } catch (error) {
                    console.warn(`Error saving ${key} to storage:`, error);
                }
            };

            // Enhanced player data structure
            const [players, setPlayers] = useState(() => {
                const saved = localStorage.getItem(`volleyball_players_${teamSlots.active}`);
                if (saved) {
                    const parsedPlayers = JSON.parse(saved);
                    return parsedPlayers.map(p => ({
                        ...p,
                        serveReceive: p.serveReceive || 3,
                        setting: p.setting || 3,
                        allAround: p.allAround || 3,
                        subPair: p.subPair || null,
                        subColor: p.subColor || null,
                        isFullTime: p.isFullTime || false
                    }));
                }
                return [
                    { id: 1, name: '1', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 2, name: '2', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 3, name: '3', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 4, name: '4', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 5, name: '5', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 6, name: '6', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 7, name: '7', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 8, name: '8', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 9, name: '9', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 10, name: '10', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false }
                ];
            });

            // Enhanced substitution tracking
            const [substitutionCount, setSubstitutionCount] = useState(0);
            const [subHistory, setSubHistory] = useState([]);
            const [rotationCount, setRotationCount] = useState(0);

            const [showPlayerForm, setShowPlayerForm] = useState(false);
            const [editingPlayer, setEditingPlayer] = useState(null);
            const [teamName, setTeamName] = useState(() => loadFromStorage('volleyball_teamName', teamSlots[teamSlots.active].name));
            const [minThreshold, setMinThreshold] = useState(() => loadFromStorage('volleyball_minThreshold', 6));
            const [isOptimizing, setIsOptimizing] = useState(false);
            const [draggedPlayer, setDraggedPlayer] = useState(null);
            const [dropZone, setDropZone] = useState(null);
            const [bestLineups, setBestLineups] = useState([]);
            const [currentLineupIndex, setCurrentLineupIndex] = useState(0);

            // Enhanced form state with mode-specific attributes
            const [playerForm, setPlayerForm] = useState({
                name: '',
                defense: 3,
                serving: 3,
                serveReceive: 3,
                setting: 3,
                allAround: 3,
                active: true,
                star: false
            });

            // Court positions
            const [courtPositions, setCourtPositions] = useState(() => 
                loadFromStorage('volleyball_courtPositions', {
                    backLeft: null,
                    frontLeft: null,
                    frontMiddle: null,
                    frontRight: null,
                    backRight: null,
                    backMiddle: null,
                    bench: []
                })
            );
// Fixed team switching with proper slot rotation
            const switchTeam = (targetSlot) => {
                // Save current team data before switching
                saveToStorage('volleyball_players', players);
                saveToStorage('volleyball_teamName', teamName);
                saveToStorage('volleyball_minThreshold', minThreshold);
                saveToStorage('volleyball_courtPositions', courtPositions);
                localStorage.setItem(`volleyball_playMode_${teamSlots.active}`, playMode);
                
                // Update team name in slots
                const currentActiveSlot = teamSlots.active;
                const updatedSlots = {
                    ...teamSlots,
                    active: targetSlot,
                    [currentActiveSlot]: { ...teamSlots[currentActiveSlot], name: teamName, hasData: true }
                };
                
                setTeamSlots(updatedSlots);
                localStorage.setItem('volleyball_teamSlots', JSON.stringify(updatedSlots));
                
                // Load target team data
                const targetTeamData = localStorage.getItem(`volleyball_players_${targetSlot}`);
                if (targetTeamData) {
                    const parsedPlayers = JSON.parse(targetTeamData);
                    setPlayers(parsedPlayers.map(p => ({
                        ...p,
                        serveReceive: p.serveReceive || 3,
                        setting: p.setting || 3,
                        allAround: p.allAround || 3,
                        subPair: p.subPair || null,
                        subColor: p.subColor || null,
                        isFullTime: p.isFullTime || false
                    })));
                } else {
                    setPlayers([
                        { id: 1, name: '1', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 2, name: '2', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 3, name: '3', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 4, name: '4', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 5, name: '5', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 6, name: '6', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 7, name: '7', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 8, name: '8', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 9, name: '9', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 10, name: '10', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false }
                    ]);
                }
                
                // Load other team-specific data
                const targetTeamName = localStorage.getItem(`volleyball_teamName_${targetSlot}`);
                setTeamName(targetTeamName ? JSON.parse(targetTeamName) : updatedSlots[targetSlot].name);
                
                const targetMinThreshold = localStorage.getItem(`volleyball_minThreshold_${targetSlot}`);
                setMinThreshold(targetMinThreshold ? JSON.parse(targetMinThreshold) : 6);
                
                const targetCourtPositions = localStorage.getItem(`volleyball_courtPositions_${targetSlot}`);
                setCourtPositions(targetCourtPositions ? JSON.parse(targetCourtPositions) : {
                    backLeft: null, frontLeft: null, frontMiddle: null,
                    frontRight: null, backRight: null, backMiddle: null, bench: []
                });
                
                const targetPlayMode = localStorage.getItem(`volleyball_playMode_${targetSlot}`);
                setPlayMode(targetPlayMode || 'rotational');
                
                // Reset optimization and substitution state
                setBestLineups([]);
                setCurrentLineupIndex(0);
                setSubstitutionCount(0);
                setSubHistory([]);
                setRotationCount(0);
            };

            // Save to localStorage whenever data changes
            useEffect(() => {
                saveToStorage('volleyball_players', players);
            }, [players]);

            useEffect(() => {
                saveToStorage('volleyball_teamName', teamName);
                // Update team name in slots
                setTeamSlots(prev => {
                    const updated = {
                        ...prev,
                        [prev.active]: { ...prev[prev.active], name: teamName }
                    };
                    localStorage.setItem('volleyball_teamSlots', JSON.stringify(updated));
                    return updated;
                });
            }, [teamName]);

            useEffect(() => {
                saveToStorage('volleyball_minThreshold', minThreshold);
            }, [minThreshold]);

            useEffect(() => {
                saveToStorage('volleyball_courtPositions', courtPositions);
            }, [courtPositions]);

            useEffect(() => {
                localStorage.setItem(`volleyball_playMode_${teamSlots.active}`, playMode);
            }, [playMode, teamSlots.active]);

            // PWA Install Prompt Handling
            useEffect(() => {
                const handleBeforeInstallPrompt = (e) => {
                    e.preventDefault();
                    setDeferredPrompt(e);
                    setShowInstallPrompt(true);
                };

                const handleAppInstalled = () => {
                    setShowInstallPrompt(false);
                    setDeferredPrompt(null);
                };

                window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
                window.addEventListener('appinstalled', handleAppInstalled);

                return () => {
                    window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
                    window.removeEventListener('appinstalled', handleAppInstalled);
                };
            }, []);

            // Register Service Worker
            useEffect(() => {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('./sw.js')
                        .then((registration) => {
                            console.log('SW registered: ', registration);
                        })
                        .catch((registrationError) => {
                            console.log('SW registration failed: ', registrationError);
                        });
                }
            }, []);

            const handleInstallClick = async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    if (outcome === 'accepted') {
                        setShowInstallPrompt(false);
                    }
                    setDeferredPrompt(null);
                }
            };

            // Enhanced color assignment utility with better contrast
            const SUB_COLORS = ['sub-color-1', 'sub-color-2', 'sub-color-3', 'sub-color-4', 'sub-color-5', 'sub-color-6'];

            // Get available sub colors
            const getAvailableSubColors = () => {
                const usedColors = new Set(players.map(p => p.subColor).filter(p => p !== null));
                return SUB_COLORS.filter((_, index) => !usedColors.has(index));
            };

            // Enhanced player management functions
            const handleAddPlayer = () => {
                if (playerForm.name.trim()) {
                    const newPlayer = {
                        id: Date.now(),
                        ...playerForm,
                        subPair: null,
                        subColor: null,
                        isFullTime: false
                    };
                    setPlayers([...players, newPlayer]);
                    setPlayerForm({ 
                        name: '', 
                        defense: 3, 
                        serving: 3, 
                        serveReceive: 3, 
                        setting: 3, 
                        allAround: 3, 
                        active: true, 
                        star: false 
                    });
                    setShowPlayerForm(false);
                }
            };

            const handleEditPlayer = (player) => {
                if (draggedPlayer) return;
                setEditingPlayer(player.id);
                setPlayerForm({
                    name: player.name,
                    defense: player.defense,
                    serving: player.serving,
                    serveReceive: player.serveReceive || 3,
                    setting: player.setting || 3,
                    allAround: player.allAround || 3,
                    active: player.active,
                    star: player.star
                });
                setShowPlayerForm(true);
            };
const handleUpdatePlayer = () => {
                setPlayers(players.map(p => 
                    p.id === editingPlayer ? { 
                        ...p, 
                        name: playerForm.name,
                        defense: playerForm.defense,
                        serving: playerForm.serving,
                        serveReceive: playerForm.serveReceive,
                        setting: playerForm.setting,
                        allAround: playerForm.allAround,
                        active: playerForm.active,
                        star: playerForm.star
                    } : p
                ));
                setEditingPlayer(null);
                setPlayerForm({ 
                    name: '', 
                    defense: 3, 
                    serving: 3, 
                    serveReceive: 3, 
                    setting: 3, 
                    allAround: 3, 
                    active: true, 
                    star: false 
                });
                setShowPlayerForm(false);
            };

            const togglePlayerActive = (id) => {
                setPlayers(players.map(p => 
                    p.id === id ? { ...p, active: !p.active } : p
                ));
            };

            const togglePlayerStar = (id) => {
                const currentStars = players.filter(p => p.star).length;
                const targetPlayer = players.find(p => p.id === id);
                
                if (!targetPlayer.star && currentStars >= 3) {
                    return;
                }
                
                setPlayers(players.map(p => 
                    p.id === id ? { ...p, star: !p.star } : p
                ));
            };

            // Fixed substitution pairing functions with proper color assignment
            const createSubPair = (player1Id, player2Id) => {
                const availableColors = getAvailableSubColors();
                if (availableColors.length === 0) return false;

                const colorIndex = SUB_COLORS.indexOf(availableColors[0]);

                setPlayers(prev => prev.map(p => {
                    if (p.id === player1Id || p.id === player2Id) {
                        return { 
                            ...p, 
                            subPair: p.id === player1Id ? player2Id : player1Id,
                            subColor: colorIndex,
                            isFullTime: false
                        };
                    }
                    return p;
                }));
                return true;
            };

            const removeSubPair = (playerId) => {
                const player = players.find(p => p.id === playerId);
                if (!player || !player.subPair) return;

                const pairId = player.subPair;
                setPlayers(prev => prev.map(p => {
                    if (p.id === playerId || p.id === pairId) {
                        return { ...p, subPair: null, subColor: null, isFullTime: false };
                    }
                    return p;
                }));
            };

            const changeSubColor = (playerId, newColorIndex) => {
                const player = players.find(p => p.id === playerId);
                if (!player || !player.subPair) return;

                const pairId = player.subPair;
                setPlayers(prev => prev.map(p => {
                    if (p.id === playerId || p.id === pairId) {
                        return { ...p, subColor: newColorIndex };
                    }
                    return p;
                }));
            };

            // Check if a position is in back row
            const isBackRowPosition = (position) => {
                return ['backLeft', 'backMiddle', 'backRight'].includes(position);
            };

            // Determine which players should be full-time (no subs) based on roster size
            const determineFullTimePlayers = (activePlayers) => {
                if (activePlayers.length <= 6) {
                    // Not enough players for any subs - all are full-time
                    return activePlayers.map(p => p.id);
                }
                
                const availableForPairing = activePlayers.length - (activePlayers.filter(p => p.star).length);
                const needFullTime = availableForPairing % 2; // Odd number means someone needs to be full-time
                
                if (needFullTime === 0) return [];
                
                // Select highest all-around rated players as full-time
                const sortedByAllAround = activePlayers
                    .filter(p => !p.star) // Stars are already marked as no-sub
                    .sort((a, b) => b.allAround - a.allAround);
                    
                return sortedByAllAround.slice(0, needFullTime).map(p => p.id);
            };

            // FIXED: Enhanced substitutional play optimization algorithm
            const optimizeSubstitutionalPlay = async () => {
                setIsOptimizing(true);
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const activePlayers = players.filter(p => p.active);
                const noSubPlayers = activePlayers.filter(p => p.star);
                
                if (activePlayers.length < 6) {
                    alert("Need at least 6 active players for optimization.");
                    setIsOptimizing(false);
                    return;
                }

                // Step 1: Determine full-time players
                const fullTimePlayerIds = determineFullTimePlayers(activePlayers);
                
                // Step 2: Generate optimal pairings based on complementary skills
                const pairablePlayers = activePlayers.filter(p => !p.star && !fullTimePlayerIds.includes(p.id));
                const pairings = [];
                const unpaired = [...pairablePlayers];
                
                while (unpaired.length >= 2) {
                    let bestPair = null;
                    let bestScore = -1;
                    
                    for (let i = 0; i < unpaired.length - 1; i++) {
                        for (let j = i + 1; j < unpaired.length; j++) {
                            const p1 = unpaired[i];
                            const p2 = unpaired[j];
                            
                            // Score based on complementary skills - prefer different strengths
                            const srDifference = Math.abs(p1.serveReceive - p2.serveReceive);
                            const settingDifference = Math.abs(p1.setting - p2.setting);
                            const allAroundSum = p1.allAround + p2.allAround;
                            
                            // Higher score for complementary skills
                            const pairScore = allAroundSum + (srDifference * 2) + (settingDifference * 2);
                            
                            if (pairScore > bestScore) {
                                bestScore = pairScore;
                                bestPair = [i, j];
                            }
                        }
                    }
                    
                    if (bestPair) {
                        const [i, j] = bestPair;
                        const p1 = unpaired[i];
                        const p2 = unpaired[j];
                        
                        pairings.push([p1.id, p2.id]);
                        
                        // Remove paired players (remove higher index first)
                        unpaired.splice(Math.max(i, j), 1);
                        unpaired.splice(Math.min(i, j), 1);
                    } else {
                        break;
                    }
                }

                // Step 3: FIXED - Apply the pairings with automatic color assignment and proper persistence
const updatedPlayers = [...players];

// Clear existing pairs first
updatedPlayers.forEach(p => {
    if (!p.star) {  // Don't clear star players
        p.subPair = null;
        p.subColor = null;
        p.isFullTime = false;
    }
});

// Mark full-time players
fullTimePlayerIds.forEach(id => {
    const player = updatedPlayers.find(p => p.id === id);
    if (player) player.isFullTime = true;
});

// Apply pairings with colors
pairings.forEach(([id1, id2], index) => {
    const p1 = updatedPlayers.find(p => p.id === id1);
    const p2 = updatedPlayers.find(p => p.id === id2);
    
    if (p1 && p2) {
        const assignedColor = index % SUB_COLORS.length;
        p1.subPair = id2;
        p1.subColor = assignedColor;
        p2.subPair = id1;
        p2.subColor = assignedColor;
    }
});

// Update state with fixed color assignment
setPlayers(updatedPlayers);
        // Step 4: FIXED - Generate optimal starting lineup ensuring NO paired players on court together
const courtPlayers = [];
const benchPlayers = [];

// Add all no-sub and full-time players to court first
const priorityPlayers = updatedPlayers.filter(p => 
    p.active && (p.star || p.isFullTime)
);
courtPlayers.push(...priorityPlayers);

// FIXED: Add exactly ONE player from each sub pair to court
const processedPairs = new Set();
updatedPlayers.forEach(player => {
    if (player.subPair && !processedPairs.has(player.id) && !processedPairs.has(player.subPair)) {
        const partner = updatedPlayers.find(p => p.id === player.subPair);
        if (partner && courtPlayers.length < 6) {
            // Choose the better serve receive player to start
            const starterPlayer = player.serveReceive >= partner.serveReceive ? player : partner;
            const benchPlayer = starterPlayer === player ? partner : player;
            
            courtPlayers.push(starterPlayer);
            benchPlayers.push(benchPlayer);
            
            processedPairs.add(player.id);
            processedPairs.add(partner.id);
        } else if (partner) {
            // Court is full, both go to bench
            benchPlayers.push(player, partner);
            processedPairs.add(player.id);
            processedPairs.add(partner.id);
        }
    }
});

// Fill remaining court spots if needed
const remainingPlayers = updatedPlayers.filter(p => 
    p.active && !courtPlayers.includes(p) && !benchPlayers.includes(p)
);
while (courtPlayers.length < 6 && remainingPlayers.length > 0) {
    courtPlayers.push(remainingPlayers.shift());
}
benchPlayers.push(...remainingPlayers);
                // Step 5: FIXED - Optimize court positions with no-sub distribution and top player placement
const optimizePositions = (courtPlayerList) => {
    if (courtPlayerList.length < 6) return null;
    
    const noSubPlayers = courtPlayerList.filter(p => p.star || p.isFullTime);
    const subPlayers = courtPlayerList.filter(p => !p.star && !p.isFullTime);
    
    // Sort players by overall rating to identify top player
    const sortedByOverall = [...courtPlayerList].sort((a, b) => b.allAround - a.allAround);
    const topPlayer = sortedByOverall[0];
    
    // Sort by serve receive to identify worst SR player
    const sortedBySR = [...courtPlayerList].sort((a, b) => a.serveReceive - b.serveReceive);
    const worstSRPlayer = sortedBySR[0];
    
    // Initialize positions
    let positions = {
        backLeft: null, backMiddle: null, backRight: null,
        frontLeft: null, frontMiddle: null, frontRight: null,
        bench: benchPlayers
    };
    
    const usedPlayers = new Set();
    
    // Step 1: Distribute no-sub players to ensure at least one in each row
    if (noSubPlayers.length >= 2) {
        // Place first no-sub in front left
        positions.frontLeft = noSubPlayers[0];
        usedPlayers.add(noSubPlayers[0]);
        
        // Place second no-sub in back right (opposite rotation)
        positions.backRight = noSubPlayers[1];
        usedPlayers.add(noSubPlayers[1]);
        
        // If there's a third no-sub player, place in remaining position
        if (noSubPlayers.length >= 3 && !usedPlayers.has(noSubPlayers[2])) {
            positions.backMiddle = noSubPlayers[2];
            usedPlayers.add(noSubPlayers[2]);
        }
    } else if (noSubPlayers.length === 1) {
        positions.frontLeft = noSubPlayers[0];
        usedPlayers.add(noSubPlayers[0]);
    }
    
    // Step 2: Place worst SR player in back row (server position preferred)
    if (!usedPlayers.has(worstSRPlayer)) {
        if (positions.backLeft === null) {
            positions.backLeft = worstSRPlayer;
        } else if (positions.backMiddle === null) {
            positions.backMiddle = worstSRPlayer;
        } else if (positions.backRight === null) {
            positions.backRight = worstSRPlayer;
        }
        usedPlayers.add(worstSRPlayer);
    }
    
    // Step 3: Place top player adjacent to worst SR player (if not already placed)
    if (!usedPlayers.has(topPlayer)) {
        let adjacentPosition = null;
        
        // Find where worst SR player was placed and choose adjacent position
        if (positions.backLeft === worstSRPlayer) {
            adjacentPosition = positions.frontLeft === null ? 'frontLeft' : 'backMiddle';
        } else if (positions.backMiddle === worstSRPlayer) {
            adjacentPosition = positions.frontMiddle === null ? 'frontMiddle' : 
                             (positions.frontLeft === null ? 'frontLeft' : 'frontRight');
        } else if (positions.backRight === worstSRPlayer) {
            adjacentPosition = positions.frontRight === null ? 'frontRight' : 'backMiddle';
        }
        
        if (adjacentPosition && positions[adjacentPosition] === null) {
            positions[adjacentPosition] = topPlayer;
            usedPlayers.add(topPlayer);
        }
    }
    
    // Step 4: Fill remaining positions with available players
    const remainingPlayers = courtPlayerList.filter(p => !usedPlayers.has(p));
    const backPositions = ['backLeft', 'backMiddle', 'backRight'];
    const frontPositions = ['frontLeft', 'frontMiddle', 'frontRight'];
    
    // Fill back row with best remaining SR players
    backPositions.forEach(pos => {
        if (positions[pos] === null && remainingPlayers.length > 0) {
            const bestSR = remainingPlayers.sort((a, b) => b.serveReceive - a.serveReceive)[0];
            positions[pos] = bestSR;
            remainingPlayers.splice(remainingPlayers.indexOf(bestSR), 1);
        }
    });
    
    // Fill front row with best remaining setting players
    frontPositions.forEach(pos => {
        if (positions[pos] === null && remainingPlayers.length > 0) {
            const bestSetting = remainingPlayers.sort((a, b) => b.setting - a.setting)[0];
            positions[pos] = bestSetting;
            remainingPlayers.splice(remainingPlayers.indexOf(bestSetting), 1);
        }
    });
    
    return positions;
};

                const bestLineup = optimizePositions(courtPlayers);
                
                if (bestLineup) {
                    setCourtPositions(bestLineup);
                    setBestLineups([{ positions: bestLineup, score: 100 }]);
                }
                
                setSubstitutionCount(0);
                setSubHistory([]);
                setRotationCount(0);
                setIsOptimizing(false);
            };

// FIXED: Rotation with automatic substitutions based on position requirements
const rotateWithSubstitutions = (direction) => {
    let newPositions;
    
    if (direction === 'forward') {
        newPositions = {
            backRight: courtPositions.backMiddle,
            frontRight: courtPositions.backRight,
            frontMiddle: courtPositions.frontRight,
            frontLeft: courtPositions.frontMiddle,
            backLeft: courtPositions.frontLeft,
            backMiddle: courtPositions.backLeft,
            bench: [...courtPositions.bench]
        };
    } else {
        newPositions = {
            frontLeft: courtPositions.backLeft,
            frontMiddle: courtPositions.frontLeft,
            frontRight: courtPositions.frontMiddle,
            backRight: courtPositions.frontRight,
            backMiddle: courtPositions.backRight,
            backLeft: courtPositions.backMiddle,
            bench: [...courtPositions.bench]
        };
    }

    // FIXED: Check for required substitutions after rotation
    const substitutions = [];

    // Don't perform substitutions if we're at rotation 0 (initial setup)
if (rotationCount === 0 && direction === 'forward') {
    setCourtPositions(newPositions);
    setRotationCount(1);
    return;
}
    Object.keys(newPositions).forEach(position => {
    if (position === 'bench') return;
    
    const currentPlayer = newPositions[position];
    if (!currentPlayer || !currentPlayer.subPair) return;
    
    const partner = players.find(p => p.id === currentPlayer.subPair);
    if (!partner) return;
    
    const isBackRow = isBackRowPosition(position);
    
    // Enhanced logic: Ensure fair play by alternating players based on position needs
    let shouldSubstitute;
    
    if (isBackRow) {
        // Back row: substitute if partner has better OR EQUAL serve receive (fair play)
        shouldSubstitute = partner.serveReceive >= currentPlayer.serveReceive;
    } else {
        // Front row: Always substitute unless current player has better setting AND better/equal SR
        if (currentPlayer.setting > partner.setting && currentPlayer.serveReceive >= partner.serveReceive) {
            // Current player is clearly better suited for front row - keep them
            shouldSubstitute = false;
        } else if (partner.setting > currentPlayer.setting) {
            // Partner has better setting - substitute them in
            shouldSubstitute = true;
        } else {
            // Equal or mixed skills - ensure fair play by checking who played back row
            // If current player has better SR, they should have played back row, so substitute them out for fair play
            shouldSubstitute = currentPlayer.serveReceive >= partner.serveReceive;
        }
    }
    
    if (shouldSubstitute && newPositions.bench.includes(partner)) {
        let reason;
        if (isBackRow) {
            reason = partner.serveReceive > currentPlayer.serveReceive ? 'Better SR for back row' : 'Fair play rotation';
        } else {
            if (partner.setting > currentPlayer.setting) {
                reason = 'Better setting for front row';
            } else if (currentPlayer.serveReceive >= partner.serveReceive) {
                reason = 'Fair play rotation';
            } else {
                reason = 'Position rotation';
            }
        }
                
        substitutions.push({
            position,
            outPlayer: currentPlayer,
            inPlayer: partner,
            reason: reason
        });
    }
});

    // Apply substitutions
    substitutions.forEach(sub => {
        newPositions[sub.position] = sub.inPlayer;
        
        // Remove incoming player from bench
        const benchIndex = newPositions.bench.findIndex(p => p.id === sub.inPlayer.id);
        if (benchIndex >= 0) {
            newPositions.bench.splice(benchIndex, 1);
        }
        
        // Add outgoing player to bench
        newPositions.bench.push(sub.outPlayer);
        
        // Update tracking - add for forward, subtract for backward
        if (direction === 'forward') {
            setSubstitutionCount(prev => prev + 1);
            setSubHistory(prev => [...prev, {
                rotation: rotationCount + (direction === 'forward' ? 1 : -1),
                out: sub.outPlayer.name,
                in: sub.inPlayer.name,
                reason: sub.reason
            }]);
        } else {
            setSubstitutionCount(prev => Math.max(0, prev - 1));
            setSubHistory(prev => prev.slice(0, -1)); // Remove last entry
        }
    });

    setCourtPositions(newPositions);
    setRotationCount(prev => direction === 'forward' ? prev + 1 : Math.max(0, prev - 1));
};
            // Export team data
            const exportData = () => {
                const data = {
                    players,
                    teamName,
                    minThreshold,
                    courtPositions,
                    playMode,
                    teamSlots,
                    exportDate: new Date().toISOString()
                };
                
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `volleyball_team_${teamName.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
            };

            // Import team data
            const handleImportData = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        if (importedData.players) setPlayers(importedData.players);
                        if (importedData.teamName) setTeamName(importedData.teamName);
                        if (importedData.minThreshold) setMinThreshold(importedData.minThreshold);
                        if (importedData.courtPositions) setCourtPositions(importedData.courtPositions);
                        if (importedData.playMode) setPlayMode(importedData.playMode);
                        if (importedData.teamSlots) setTeamSlots(importedData.teamSlots);
                        
                        alert('Team data imported successfully!');
                    } catch (error) {
                        alert('Error importing data. Please check the file format.');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            };
        // Helper function to check star player rules for rotational mode
            const checkStarRules = (positions) => {
                const courtPlayers = [
                    positions.backLeft,
                    positions.frontLeft,
                    positions.frontMiddle,
                    positions.frontRight,
                    positions.backRight,
                    positions.backMiddle
                ].filter(Boolean);

                const starsOnCourt = courtPlayers.filter(p => p.star).length;
                
                if (starsOnCourt === 0) return false;

                const starPositions = [];
                if (positions.backLeft?.star) starPositions.push(1);
                if (positions.frontLeft?.star) starPositions.push(2);
                if (positions.frontMiddle?.star) starPositions.push(3);
                if (positions.frontRight?.star) starPositions.push(4);
                if (positions.backRight?.star) starPositions.push(5);
                if (positions.backMiddle?.star) starPositions.push(6);

                for (let i = 0; i < starPositions.length; i++) {
                    for (let j = i + 1; j < starPositions.length; j++) {
                        const pos1 = starPositions[i];
                        const pos2 = starPositions[j];
                        
                        if (Math.abs(pos1 - pos2) === 1 || (pos1 === 1 && pos2 === 6) || (pos1 === 6 && pos2 === 1)) {
                            return false;
                        }
                    }
                }

                return true;
            };

            // Calculate rotation strengths for rotational mode
            const calculateRotationStrengths = (positions) => {
                const rotations = [];
                let currentPositions = { ...positions };
                
                for (let i = 0; i < 10; i++) {
                    const frontRowTotal = (currentPositions.frontLeft?.defense || 0) + 
                                         (currentPositions.frontMiddle?.defense || 0) + 
                                         (currentPositions.frontRight?.defense || 0);
                    const backRowTotal = (currentPositions.backLeft?.defense || 0) + 
                                        (currentPositions.backMiddle?.defense || 0) + 
                                        (currentPositions.backRight?.defense || 0);
                    
                    rotations.push({
                        frontRowTotal,
                        backRowTotal,
                        serverRating: currentPositions.backLeft?.serving || 0,
                        rotation: i
                    });
                    
                    const newPositions = {
                        backRight: currentPositions.backMiddle,
                        frontRight: currentPositions.backRight,
                        frontMiddle: currentPositions.frontRight,
                        frontLeft: currentPositions.frontMiddle,
                        backLeft: currentPositions.frontLeft,
                        bench: [...currentPositions.bench]
                    };
                    
                    const newBench = [...currentPositions.bench];
                    if (newBench.length > 0) {
                        newBench.push(currentPositions.backLeft);
                        newPositions.backMiddle = newBench.shift();
                    } else {
                        newPositions.backMiddle = currentPositions.backLeft;
                    }
                    newPositions.bench = newBench;
                    
                    currentPositions = newPositions;
                }
                
                return rotations;
            };

            // Serving Priority Optimization with Star Rules
            const optimizeServingPriority = async () => {
                if (playMode === 'substitutional') {
                    optimizeSubstitutionalPlay();
                    return;
                }

                setIsOptimizing(true);
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const activePlayers = players.filter(p => p.active);
                const starPlayers = activePlayers.filter(p => p.star);
                
                if (activePlayers.length < 6) {
                    setIsOptimizing(false);
                    return;
                }

                if (starPlayers.length === 0) {
                    alert("Please select at least 1 star player to use optimization.");
                    setIsOptimizing(false);
                    return;
                }

                let eligibleServers = starPlayers.filter(p => p.serving >= 3);
                if (eligibleServers.length === 0) {
                    eligibleServers = activePlayers.filter(p => p.serving >= 3);
                }
                if (eligibleServers.length === 0) {
                    eligibleServers = [...starPlayers].sort((a, b) => b.serving - a.serving).slice(0, 1);
                }
                
                const firstServer = eligibleServers.sort((a, b) => a.defense - b.defense)[0];
                const remainingPlayers = activePlayers.filter(p => p.id !== firstServer.id);
                const topServers = remainingPlayers.sort((a, b) => b.serving - a.serving).slice(0, 5);
                const benchPlayers = remainingPlayers.filter(p => !topServers.some(ts => ts.id === p.id))
                    .sort((a, b) => b.defense - a.defense);

                let allLineups = [];

                const generatePermutations = (arr, current = []) => {
                    if (current.length === arr.length) {
                        return [current];
                    }
                    const perms = [];
                    for (let i = 0; i < arr.length; i++) {
                        if (!current.includes(arr[i])) {
                            const newCurrent = [...current, arr[i]];
                            perms.push(...generatePermutations(arr, newCurrent));
                        }
                    }
                    return perms;
                };

                const serverPermutations = generatePermutations(topServers);

                for (const perm of serverPermutations) {
                    const testPositions = {
                        backLeft: firstServer,
                        frontLeft: perm[0],
                        frontMiddle: perm[1],
                        frontRight: perm[2],
                        backRight: perm[3],
                        backMiddle: perm[4],
                        bench: benchPlayers
                    };

                    if (!checkStarRules(testPositions)) continue;

                    const rotations = calculateRotationStrengths(testPositions);
                    
                    let aboveThresholdCount = 0;
                    let totalDefense = 0;
                    let servingScore = 0;
                    let starBonus = 0;

                    rotations.forEach((rotation, index) => {
                        if (rotation.frontRowTotal >= minThreshold && rotation.backRowTotal >= minThreshold) {
                            aboveThresholdCount++;
                        }
                        totalDefense += rotation.frontRowTotal + rotation.backRowTotal;
                        
                        const rotationWeight = Math.max(1, 20 - (index * 2));
                        servingScore += rotation.serverRating * rotationWeight;

                        let currentPos = { ...testPositions };
                        for (let r = 0; r < index; r++) {
                            const newPos = {
                                backRight: currentPos.backMiddle,
                                frontRight: currentPos.backRight,
                                frontMiddle: currentPos.frontRight,
                                frontLeft: currentPos.frontMiddle,
                                backLeft: currentPos.frontLeft,
                                bench: [...currentPos.bench]
                            };
                            const newBench = [...currentPos.bench];
                            if (newBench.length > 0) {
                                newBench.push(currentPos.backLeft);
                                newPos.backMiddle = newBench.shift();
                            } else {
                                newPos.backMiddle = currentPos.backLeft;
                            }
                            newPos.bench = newBench;
                            currentPos = newPos;
                        }

                        const courtPlayers = [currentPos.backLeft, currentPos.frontLeft, currentPos.frontMiddle,
                                            currentPos.frontRight, currentPos.backRight, currentPos.backMiddle];
                        const starsOnCourt = courtPlayers.filter(p => p && p.star).length;
                        if (starsOnCourt >= 2) starBonus += 3;
                    });

                    const avgDefense = totalDefense / rotations.length;
                    const thresholdPercent = aboveThresholdCount / rotations.length;
                    const score = (servingScore * 1.0) + (avgDefense * 2) + (thresholdPercent * 50) + starBonus;

                    allLineups.push({
                        positions: testPositions,
                        score: score,
                        thresholdPercent: thresholdPercent,
                        avgDefense: avgDefense,
                        servingScore: servingScore,
                        starBonus: starBonus
                    });
                }

                allLineups.sort((a, b) => b.score - a.score);
                const topLineups = allLineups.slice(0, 10);
                
                setBestLineups(topLineups);
                setCurrentLineupIndex(0);

                if (topLineups.length > 0) {
                    setCourtPositions(topLineups[0].positions);
                }
                
                setIsOptimizing(false);
            };
        const optimizeStandardPlay = async () => {
    setIsOptimizing(true);
    
    await new Promise(resolve => setTimeout(resolve, 100));
    
    const activePlayers = players.filter(p => p.active);
    const starPlayers = activePlayers.filter(p => p.star);
    
    if (activePlayers.length < 6) {
        setIsOptimizing(false);
        return;
    }

    if (starPlayers.length === 0) {
        alert("Please select at least 1 star player to use optimization.");
        setIsOptimizing(false);
        return;
    }

    // Rank ALL active players by defense (with serving as tiebreaker)
    const rankedPlayers = [...activePlayers].sort((a, b) => {
        if (a.defense === b.defense) {
            return b.serving - a.serving;
        }
        return b.defense - a.defense;
    });

    // Create alternating pattern for full rotation
    // Pair: 1st with last, 2nd with 2nd-to-last, etc.
    const totalPlayers = rankedPlayers.length;
    const rotationOrder = [];
    
    // Build alternating pairs: high with low, with higher ranked ahead
    for (let i = 0; i < Math.floor(totalPlayers / 2); i++) {
        const highRanked = rankedPlayers[i];
        const lowRanked = rankedPlayers[totalPlayers - 1 - i];
        
        // Higher ranked player goes first in rotation
        rotationOrder.push(highRanked);
        rotationOrder.push(lowRanked);
    }
    
    // If odd number of players, add the middle player at the end
    if (totalPlayers % 2 === 1) {
        const middlePlayer = rankedPlayers[Math.floor(totalPlayers / 2)];
        rotationOrder.push(middlePlayer);
    }

    // Starting positions: first 6 from rotation order
    const startingPositions = {
        backLeft: rotationOrder[0],       // Server position
        frontLeft: rotationOrder[1],      
        frontMiddle: rotationOrder[2],    
        frontRight: rotationOrder[3],     
        backRight: rotationOrder[4],      
        backMiddle: rotationOrder[5],     
        bench: rotationOrder.slice(6)     // Rest on bench
    };

    // Check star player rules
    if (!checkStarRules(startingPositions)) {
        // Try different starting rotations to find valid star arrangement
        let validArrangement = null;
        
        for (let startOffset = 1; startOffset < Math.min(6, totalPlayers); startOffset++) {
            const testPositions = {
                backLeft: rotationOrder[startOffset % totalPlayers],
                frontLeft: rotationOrder[(startOffset + 1) % totalPlayers],
                frontMiddle: rotationOrder[(startOffset + 2) % totalPlayers],
                frontRight: rotationOrder[(startOffset + 3) % totalPlayers],
                backRight: rotationOrder[(startOffset + 4) % totalPlayers],
                backMiddle: rotationOrder[(startOffset + 5) % totalPlayers],
                bench: [
                    ...rotationOrder.slice(0, startOffset),
                    ...rotationOrder.slice(startOffset + 6)
                ]
            };
            
            if (checkStarRules(testPositions)) {
                validArrangement = testPositions;
                break;
            }
        }

        if (validArrangement) {
            setCourtPositions(validArrangement);
        } else {
            alert("Cannot find valid rotation that follows star player rules. Try adjusting star player positions.");
            setIsOptimizing(false);
            return;
        }
    } else {
        setCourtPositions(startingPositions);
    }

    // Verify rotation quality - check all possible 6-player combinations
    const finalLineup = startingPositions;
    const rotations = calculateRotationStrengths(finalLineup);
    
    let aboveThresholdCount = 0;
    let totalDefense = 0;
    let starBonus = 0;

    rotations.forEach((rotation, index) => {
        if (rotation.frontRowTotal >= minThreshold && rotation.backRowTotal >= minThreshold) {
            aboveThresholdCount++;
        }
        totalDefense += rotation.frontRowTotal + rotation.backRowTotal;

        // Star bonus calculation for current rotation
        let currentPos = { ...finalLineup };
        for (let r = 0; r < index; r++) {
            const newPos = {
                backRight: currentPos.backMiddle,
                frontRight: currentPos.backRight,
                frontMiddle: currentPos.frontRight,
                frontLeft: currentPos.frontMiddle,
                backLeft: currentPos.frontLeft,
                backMiddle: currentPos.backLeft,
                bench: [...currentPos.bench]
            };
            
            // Handle bench rotation
            const newBench = [...currentPos.bench];
            if (newBench.length > 0) {
                newBench.push(currentPos.backLeft);
                newPos.backMiddle = newBench.shift();
            } else {
                newPos.backMiddle = currentPos.backLeft;
            }
            newPos.bench = newBench;
            currentPos = newPos;
        }

        const courtPlayers = [currentPos.backLeft, currentPos.frontLeft, currentPos.frontMiddle,
                            currentPos.frontRight, currentPos.backRight, currentPos.backMiddle];
        const starsOnCourt = courtPlayers.filter(p => p && p.star).length;
        if (starsOnCourt >= 2) starBonus += 3;
    });

    const avgDefense = totalDefense / rotations.length;
    const thresholdPercent = aboveThresholdCount / rotations.length;
    const score = (avgDefense * 2) + (thresholdPercent * 50) + starBonus;

    const optimizedLineup = {
        positions: finalLineup,
        score: score,
        thresholdPercent: thresholdPercent,
        avgDefense: avgDefense,
        servingScore: 0,
        starBonus: starBonus
    };

    setBestLineups([optimizedLineup]);
    setCurrentLineupIndex(0);
    
    setIsOptimizing(false);
};

            const shuffleStandardPlay = () => {
                if (bestLineups.length === 0) return;
                
                const nextIndex = (currentLineupIndex + 1) % bestLineups.length;
                setCurrentLineupIndex(nextIndex);
                setCourtPositions(bestLineups[nextIndex].positions);
            };

            const autoArrangePlayers = () => {
                const activePlayers = players.filter(p => p.active);
                if (activePlayers.length < 6) return;

                const newPositions = {
                    backLeft: activePlayers.find(p => p.name === '1') || activePlayers[0],
                    frontLeft: activePlayers.find(p => p.name === '2') || activePlayers[1],
                    frontMiddle: activePlayers.find(p => p.name === '3') || activePlayers[2],
                    frontRight: activePlayers.find(p => p.name === '4') || activePlayers[3],
                    backRight: activePlayers.find(p => p.name === '5') || activePlayers[4],
                    backMiddle: activePlayers.find(p => p.name === '6') || activePlayers[5],
                    bench: activePlayers.slice(6)
                };
                setCourtPositions(newPositions);
                
                // Reset substitution tracking
                if (playMode === 'substitutional') {
                    setSubstitutionCount(0);
                    setSubHistory([]);
                    setRotationCount(0);
                }
            };

            const rotateForward = () => {
                if (playMode === 'substitutional') {
                    rotateWithSubstitutions('forward');
                    return;
                }

                const courtPlayers = [
                    courtPositions.backLeft,
                    courtPositions.backMiddle,
                    courtPositions.backRight,
                    courtPositions.frontLeft,
                    courtPositions.frontMiddle,
                    courtPositions.frontRight
                ].filter(Boolean);
                
                if (courtPlayers.length < 6) return;

                const newPositions = {
                    backRight: courtPositions.backMiddle,
                    frontRight: courtPositions.backRight,
                    frontMiddle: courtPositions.frontRight,
                    frontLeft: courtPositions.frontMiddle,
                    backLeft: courtPositions.frontLeft,
                    bench: [...courtPositions.bench]
                };

                const newBench = [...courtPositions.bench];
                newBench.push(courtPositions.backLeft);
                
                if (newBench.length > 0) {
                    newPositions.backMiddle = newBench.shift();
                }
                
                newPositions.bench = newBench;
                setCourtPositions(newPositions);
            };

            const rotateBackward = () => {
                if (playMode === 'substitutional') {
                    rotateWithSubstitutions('backward');
                    return;
                }

                const courtPlayers = [
                    courtPositions.backLeft,
                    courtPositions.backMiddle,
                    courtPositions.backRight,
                    courtPositions.frontLeft,
                    courtPositions.frontMiddle,
                    courtPositions.frontRight
                ].filter(Boolean);
                
                if (courtPlayers.length < 6) return;

                const newPositions = {
                    frontLeft: courtPositions.backLeft,
                    frontMiddle: courtPositions.frontLeft,
                    frontRight: courtPositions.frontMiddle,
                    backRight: courtPositions.frontRight,
                    backMiddle: courtPositions.backRight,
                    bench: [...courtPositions.bench]
                };

                const newBench = [...courtPositions.bench];
                newBench.unshift(courtPositions.backMiddle);
                
                if (newBench.length > 0) {
                    newPositions.backLeft = newBench.pop();
                }
                
                newPositions.bench = newBench;
                setCourtPositions(newPositions);
            };

            // Drag and Drop handlers
            const handleDragStart = (e, player) => {
                setDraggedPlayer(player);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDragEnter = (e, zone) => {
                e.preventDefault();
                setDropZone(zone);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                setDropZone(null);
            };

            const handleDrop = (e, targetPosition) => {
                e.preventDefault();
                if (!draggedPlayer) return;

                const newPositions = { ...courtPositions };
                
                let currentPosition = null;
                Object.keys(newPositions).forEach(pos => {
                    if (pos === 'bench') {
                        const benchIndex = newPositions[pos].findIndex(p => p.id === draggedPlayer.id);
                        if (benchIndex >= 0) {
                            currentPosition = { type: 'bench', index: benchIndex };
                        }
                    } else if (newPositions[pos] && newPositions[pos].id === draggedPlayer.id) {
                        currentPosition = { type: 'court', position: pos };
                    }
                });

                if (currentPosition) {
                    if (currentPosition.type === 'bench') {
                        newPositions.bench.splice(currentPosition.index, 1);
                    } else {
                        newPositions[currentPosition.position] = null;
                    }
                }

                if (targetPosition === 'bench') {
                    newPositions.bench.push(draggedPlayer);
                } else if (targetPosition.startsWith('bench-')) {
                    const index = parseInt(targetPosition.split('-')[1]);
                    newPositions.bench.splice(index, 0, draggedPlayer);
                } else {
                    if (newPositions[targetPosition]) {
                        if (currentPosition && currentPosition.type === 'court') {
                            newPositions[currentPosition.position] = newPositions[targetPosition];
                        } else if (currentPosition && currentPosition.type === 'bench') {
                            newPositions.bench.splice(currentPosition.index, 0, newPositions[targetPosition]);
                        }
                    }
                    newPositions[targetPosition] = draggedPlayer;
                }

                setCourtPositions(newPositions);
                setDraggedPlayer(null);
                setDropZone(null);
            };

            // Calculate current strengths based on play mode
            const calculateCurrentStrengths = () => {
                if (playMode === 'rotational') {
                    return calculateRotationStrengths(courtPositions).slice(0, 6);
                } else {
                    // For substitutional mode, calculate serve receive and setting strengths
                    const rotations = [];
                    let currentPositions = { ...courtPositions };
                    
                    for (let i = 0; i < 6; i++) {
                        const backRowSR = (currentPositions.backLeft?.serveReceive || 0) + 
                                         (currentPositions.backMiddle?.serveReceive || 0) + 
                                         (currentPositions.backRight?.serveReceive || 0);
                        
                        const frontRowSetting = (currentPositions.frontLeft?.setting || 0) + 
                                               (currentPositions.frontMiddle?.setting || 0) + 
                                               (currentPositions.frontRight?.setting || 0);
                        
                        rotations.push({
                            backRowSR,
                            frontRowSetting,
                            serverRating: currentPositions.backLeft?.serving || 0,
                            rotation: i
                        });
                        
                        const newPositions = {
                            backRight: currentPositions.backMiddle,
                            frontRight: currentPositions.backRight,
                            frontMiddle: currentPositions.frontRight,
                            frontLeft: currentPositions.frontMiddle,
                            backLeft: currentPositions.frontLeft,
                            backMiddle: currentPositions.backLeft,
                            bench: [...currentPositions.bench]
                        };
                        currentPositions = newPositions;
                    }
                    
                    return rotations;
                }
            };

            const currentStrengths = calculateCurrentStrengths();

            const PlayerTile = ({ player, position, isOnCourt, benchIndex }) => {
                const subColorClass = player.subColor !== null ? SUB_COLORS[player.subColor] : '';
                const isNoSub = (playMode === 'substitutional' && player.star) || player.isFullTime;
                
                return React.createElement('div', {
                    className: `p-3 rounded-lg shadow-md cursor-pointer transition-all ${
                        player.active 
                            ? (isOnCourt ? 'bg-blue-100 border-2 border-blue-500' : 'bg-green-100 border-2 border-green-400')
                            : 'bg-gray-200 border-2 border-gray-300'
                    } ${isNoSub ? 'no-sub-player' : subColorClass} ${
                        playMode === 'rotational' && player.star ? 'star-player' : ''
                    } ${draggedPlayer && draggedPlayer.id === player.id ? 'dragging' : ''}`,
                    draggable: true,
                    onDragStart: (e) => handleDragStart(e, player),
                    onClick: () => handleEditPlayer(player)
                },
                    React.createElement('div', { className: "flex items-center justify-between" },
                        React.createElement('div', { className: "font-semibold text-sm" }, player.name),
                        React.createElement('div', { className: "flex gap-1" },
                            (playMode === 'rotational' && player.star) && React.createElement('span', { className: "text-yellow-500 text-xs" }, '⭐'),
                            (playMode === 'substitutional' && (player.star || player.isFullTime)) && React.createElement('span', { className: "text-yellow-500 text-xs" }, '⭐'),
                            (playMode === 'substitutional' && player.subPair) && React.createElement('span', { className: "text-blue-500 text-xs" }, '🔗')
                        )
                    ),
                    position && React.createElement('div', { className: "text-xs text-gray-600 mt-1" }, position)
                );
            };
        const DropZone = ({ position, currentPlayer, label }) => (
                React.createElement('div', {
                    className: `h-16 border-2 border-dashed rounded-lg flex items-center justify-center transition-all ${
                        dropZone === position ? 'drop-zone-active' : 'border-gray-300'
                    }`,
                    onDragOver: handleDragOver,
                    onDragEnter: (e) => handleDragEnter(e, position),
                    onDragLeave: handleDragLeave,
                    onDrop: (e) => handleDrop(e, position)
                },
                    currentPlayer ? 
                        React.createElement(PlayerTile, { player: currentPlayer, position: label, isOnCourt: true }) :
                        React.createElement('span', { className: "text-xs text-gray-400" }, "Empty")
                )
            );

            const CourtDisplay = () => (
                React.createElement('div', { className: "bg-orange-50 border-2 border-orange-300 rounded-lg p-4 mb-6" },
                    React.createElement('div', { className: "text-center text-sm font-semibold mb-4 text-orange-800" },
                        `${teamName} - Court Layout (${playMode.charAt(0).toUpperCase() + playMode.slice(1)} Mode)`
                    ),
                    
                    // Substitution Counter for substitutional mode
                    playMode === 'substitutional' && (
                        React.createElement('div', { className: "mb-4 p-2 substitution-counter text-center text-sm" },
                            `Substitutions: ${substitutionCount} | Rotations: ${rotationCount}`
                        )
                    ),
                    
                    // Current rotation strengths
                    currentStrengths.length > 0 && (
                        React.createElement('div', { className: "mb-4 p-3 bg-white rounded-lg border" },
                            React.createElement('div', { className: "text-xs font-semibold mb-2 text-center" }, 
                                playMode === 'rotational' 
                                    ? `Row Totals (Defense) - Min: ${minThreshold}`
                                    : "Row Totals (SR: Serve Receive, Set: Setting)"
                            ),
                            React.createElement('div', { className: "flex justify-between text-xs mb-2" },
                                playMode === 'rotational' ? (
                                    React.createElement(React.Fragment, {},
                                        React.createElement('div', {}, 
                                            `Front: ${currentStrengths[0]?.frontRowTotal || 0}`,
                                            React.createElement('span', { 
                                                className: `ml-1 ${(currentStrengths[0]?.frontRowTotal || 0) >= minThreshold ? 'text-green-600' : 'text-red-600'}`
                                            }, (currentStrengths[0]?.frontRowTotal || 0) >= minThreshold ? '✓' : '✗')
                                        ),
                                        React.createElement('div', {}, 
                                            `Back: ${currentStrengths[0]?.backRowTotal || 0}`,
                                            React.createElement('span', { 
                                                className: `ml-1 ${(currentStrengths[0]?.backRowTotal || 0) >= minThreshold ? 'text-green-600' : 'text-red-600'}`
                                            }, (currentStrengths[0]?.backRowTotal || 0) >= minThreshold ? '✓' : '✗')
                                        )
                                    )
                                ) : (
                                    React.createElement(React.Fragment, {},
                                        React.createElement('div', {}, `Back SR: ${currentStrengths[0]?.backRowSR || 0}`),
                                        React.createElement('div', {}, `Front Set: ${currentStrengths[0]?.frontRowSetting || 0}`)
                                    )
                                )
                            ),
                            bestLineups.length > 0 && (
                                React.createElement('div', { className: "text-xs text-center text-gray-600" },
                                    `Lineup ${currentLineupIndex + 1} of ${bestLineups.length} best options`
                                )
                            )
                        )
                    ),

                    // Back Row (20 ft line)
                    React.createElement('div', { className: "border-b-2 border-dashed border-orange-400 pb-3 mb-3" },
                        React.createElement('div', { className: "text-xs text-center mb-2 text-orange-700" }, "Back Row (20 ft)"),
                        React.createElement('div', { className: "grid grid-cols-3 gap-2" },
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-xs mb-1" }, "Left (Serve)"),
                                React.createElement(DropZone, { 
                                    position: "backLeft", 
                                    currentPlayer: courtPositions.backLeft, 
                                    label: "BL" 
                                })
                            ),
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-xs mb-1" }, "Middle"),
                                React.createElement(DropZone, { 
                                    position: "backMiddle", 
                                    currentPlayer: courtPositions.backMiddle, 
                                    label: "BM" 
                                })
                            ),
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-xs mb-1" }, "Right"),
                                React.createElement(DropZone, { 
                                    position: "backRight", 
                                    currentPlayer: courtPositions.backRight, 
                                    label: "BR" 
                                })
                            )
                        )
                    ),

                    // Front Row (10 ft line)
                    React.createElement('div', { className: "border-b-2 border-dashed border-orange-400 pb-3 mb-3" },
                        React.createElement('div', { className: "text-xs text-center mb-2 text-orange-700" }, "Front Row (10 ft)"),
                        React.createElement('div', { className: "grid grid-cols-3 gap-2" },
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-xs mb-1" }, "Left"),
                                React.createElement(DropZone, { 
                                    position: "frontLeft", 
                                    currentPlayer: courtPositions.frontLeft, 
                                    label: "FL" 
                                })
                            ),
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-xs mb-1" }, "Middle"),
                                React.createElement(DropZone, { 
                                    position: "frontMiddle", 
                                    currentPlayer: courtPositions.frontMiddle, 
                                    label: "FM" 
                                })
                            ),
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "text-xs mb-1" }, "Right"),
                                React.createElement(DropZone, { 
                                    position: "frontRight", 
                                    currentPlayer: courtPositions.frontRight, 
                                    label: "FR" 
                                })
                            )
                        )
                    ),

                    // Net
                    React.createElement('div', { className: "w-full h-2 bg-black mb-4 rounded" }),

                    // Rotation Controls
                    React.createElement('div', { className: "flex justify-center gap-4 mb-4" },
                        React.createElement('button', {
                            onClick: rotateBackward,
                            className: "flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed",
                            disabled: [courtPositions.backLeft, courtPositions.backMiddle, courtPositions.backRight, courtPositions.frontLeft, courtPositions.frontMiddle, courtPositions.frontRight].filter(Boolean).length < 6
                        },
                            "⟲ Previous"
                        ),
                        React.createElement('button', {
                            onClick: rotateForward,
                            className: "flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed",
                            disabled: [courtPositions.backLeft, courtPositions.backMiddle, courtPositions.backRight, courtPositions.frontLeft, courtPositions.frontMiddle, courtPositions.frontRight].filter(Boolean).length < 6
                        },
                            "Next ⟳"
                        )
                    )
                )
            );

            const BenchDisplay = () => (
                React.createElement('div', { 
                    className: "bg-green-50 border-2 border-green-300 rounded-lg p-4 mb-6",
                    onDragOver: handleDragOver,
                    onDragEnter: (e) => handleDragEnter(e, 'bench'),
                    onDragLeave: handleDragLeave,
                    onDrop: (e) => handleDrop(e, 'bench')
                },
                    React.createElement('div', { className: "text-center text-sm font-semibold mb-3 text-green-800" },
                        playMode === 'substitutional' 
                            ? "Bench Players (Available for substitution)"
                            : "Bench Players (Next to rotate in at bottom)"
                    ),
                    React.createElement('div', { className: "space-y-2" },
                        courtPositions.bench.map((player, index) => (
                            React.createElement('div', { key: player.id, className: "flex items-center gap-2" },
                                React.createElement('span', { className: "text-xs w-6 text-center" }, 
                                    playMode === 'rotational' ? courtPositions.bench.length - index : index + 1
                                ),
                                React.createElement(PlayerTile, { player: player, isOnCourt: false, benchIndex: index })
                            )
                        )),
                        courtPositions.bench.length === 0 && (
                            React.createElement('div', { className: "text-center text-gray-500 text-sm" }, "No bench players")
                        )
                    )
                )
            );

            return React.createElement('div', { className: "max-w-md mx-auto bg-white min-h-screen p-4" },
                // PWA Install Prompt
                showInstallPrompt && (
                    React.createElement('div', { className: "install-prompt mb-4 p-4 text-white rounded-lg flex items-center justify-between" },
                        React.createElement('div', {},
                            React.createElement('div', { className: "font-semibold text-sm" }, "Install Volleyball App"),
                            React.createElement('div', { className: "text-xs opacity-90" }, "Add to home screen for offline use")
                        ),
                        React.createElement('div', { className: "flex gap-2" },
                            React.createElement('button', {
                                onClick: () => setShowInstallPrompt(false),
                                className: "px-3 py-1 bg-white bg-opacity-20 rounded text-xs"
                            }, "Later"),
                            React.createElement('button', {
                                onClick: handleInstallClick,
                                className: "px-3 py-1 bg-white text-purple-600 rounded text-xs font-semibold"
                            }, "Install")
                        )
                    )
                ),

                // Header with fixed team switcher
                React.createElement('div', { className: "mb-6" },
                    React.createElement('div', { className: "flex items-center justify-between mb-2" },
                        React.createElement('input', {
                            type: "text",
                            value: teamName,
                            onChange: (e) => setTeamName(e.target.value),
                            className: "text-lg font-bold bg-transparent border-b-2 border-gray-300 focus:border-blue-500 outline-none"
                        }),
                        React.createElement('div', { className: "flex gap-2" },
                            React.createElement('button', { 
                                onClick: exportData,
                                className: "p-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600",
                                title: "Export team data"
                            },
                                "💾"
                            ),
                            React.createElement('label', { 
                                className: "p-2 bg-green-500 text-white rounded-lg hover:bg-green-600 cursor-pointer",
                                title: "Import team data"
                            },
                                "📂",
                                React.createElement('input', {
                                    type: "file",
                                    accept: ".json",
                                    onChange: handleImportData,
                                    className: "hidden"
                                })
                            )
                        )
                    ),
        // Fixed Team Switcher
                    React.createElement('div', { className: "flex gap-2" },
                        ['team1', 'team2', 'team3'].filter(slot => slot !== teamSlots.active).map(slot => (
                            React.createElement('button', {
                                key: slot,
                                onClick: () => switchTeam(slot),
                                className: `flex-1 py-2 px-3 rounded text-sm font-medium transition-colors bg-gray-100 border border-gray-300 text-gray-700 hover:bg-gray-200`
                            }, teamSlots[slot].name)
                        ))
                    )
                ),

                // Play Mode Toggle
                React.createElement('div', { className: "mb-4 p-3 bg-gray-50 rounded-lg" },
                    React.createElement('div', { className: "text-sm font-medium mb-2" }, "Play Mode"),
                    React.createElement('div', { className: "flex gap-2" },
                        React.createElement('button', {
                            onClick: () => setPlayMode('rotational'),
                            className: `flex-1 py-2 px-3 rounded text-sm font-medium transition-colors ${
                                playMode === 'rotational' 
                                    ? 'bg-blue-500 text-white' 
                                    : 'bg-white border border-gray-300 text-gray-700 hover:bg-gray-50'
                            }`
                        }, "Rotational"),
                        React.createElement('button', {
                            onClick: () => setPlayMode('substitutional'),
                            className: `flex-1 py-2 px-3 rounded text-sm font-medium transition-colors ${
                                playMode === 'substitutional' 
                                    ? 'bg-green-500 text-white' 
                                    : 'bg-white border border-gray-300 text-gray-700 hover:bg-gray-50'
                            }`
                        }, "Substitutional")
                    )
                ),

                // Mode-specific info panel
                playMode === 'rotational' ? (
                    React.createElement('div', { className: "mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg" },
                        React.createElement('div', { className: "text-sm font-medium text-yellow-800 mb-1" },
                            `Star Players: ${players.filter(p => p.star).length}/3`
                        ),
                        React.createElement('div', { className: "text-xs text-yellow-700" },
                            "⭐ Select up to 3 star players for rotational optimization. Algorithms ensure 1+ star always on court and prevent adjacent positioning."
                        )
                    )
                ) : (
                    React.createElement('div', { className: "mb-4 p-3 bg-green-50 border border-green-200 rounded-lg" },
                        React.createElement('div', { className: "text-sm font-medium text-green-800 mb-1" },
                            "Substitutional Play Mode"
                        ),
                        React.createElement('div', { className: "text-xs text-green-700 mb-2" },
                            "⭐ Gold tiles = no substitution partner. Matching colors = paired for substitutions."
                        ),
                        React.createElement('div', { className: "text-xs text-green-600" },
                            `No-Sub Players: ${players.filter(p => p.star || p.isFullTime).length} | Sub Pairs: ${Math.floor(players.filter(p => p.subPair).length / 2)}`
                        )
                    )
                ),

                // Court Display
                React.createElement(CourtDisplay),
                
                // Bench Display
                React.createElement(BenchDisplay),

                // Optimization Controls
                React.createElement('div', { className: "mb-4 p-4 bg-gray-50 rounded-lg" },
                    playMode === 'rotational' && (
                        React.createElement('div', { className: "mb-3" },
                            React.createElement('label', { className: "block text-sm font-medium mb-1" }, 
                                `Minimum Row Total: ${minThreshold}`
                            ),
                            React.createElement('input', {
                                type: "range",
                                min: "3",
                                max: "15",
                                value: minThreshold,
                                onChange: (e) => setMinThreshold(parseInt(e.target.value)),
                                className: "w-full"
                            }),
                            React.createElement('div', { className: "flex justify-between text-xs text-gray-500 mt-1" },
                                React.createElement('span', {}, "3"),
                                React.createElement('span', {}, "15")
                            )
                        )
                    ),
                    React.createElement('div', { className: "flex gap-2" },
                        React.createElement('button', {
    onClick: playMode === 'rotational' ? optimizeStandardPlay : optimizeSubstitutionalPlay,
    className: `flex-1 p-3 text-white rounded-lg transition-colors ${
        isOptimizing ? 'optimizing cursor-not-allowed' : 
        playMode === 'rotational' ? 'bg-purple-500 hover:bg-purple-600' : 'bg-green-500 hover:bg-green-600'
    }`,
    disabled: isOptimizing || players.filter(p => p.active).length < 6
},
    isOptimizing ? "Optimizing..." : 
    playMode === 'rotational' ? "🎯 Standard Play" : "🎯 Optimize Subs"
),
                        playMode === 'rotational' && (
                            React.createElement('button', {
                                onClick: optimizeServingPriority,
                                className: `flex-1 p-3 text-white rounded-lg transition-colors ${
                                    isOptimizing ? 'optimizing cursor-not-allowed' : 'bg-orange-500 hover:bg-orange-600'
                                }`,
                                disabled: isOptimizing || players.filter(p => p.active).length < 6
                            },
                                isOptimizing ? "Optimizing..." : "⚡ Serving Priority"
                            )
                        ),
                        React.createElement('button', {
                            onClick: shuffleStandardPlay,
                            className: "px-3 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors disabled:bg-gray-400",
                            disabled: bestLineups.length === 0,
                            title: "Shuffle through best lineups"
                        },
                            "🔀"
                        )
                    ),
                    React.createElement('div', { className: "flex gap-2 mt-2" },
    React.createElement('button', {
        onClick: playMode === 'substitutional' ? () => {
            // Reset substitutional mode
            const resetPlayers = players.map(p => ({
                ...p,
                subPair: null,
                subColor: null,
                isFullTime: false
            }));
            setPlayers(resetPlayers);
            setCourtPositions({
                backLeft: null,
                frontLeft: null,
                frontMiddle: null,
                frontRight: null,
                backRight: null,
                backMiddle: null,
                bench: []
            });
            setBestLineups([]);
            setCurrentLineupIndex(0);
            setSubstitutionCount(0);
            setSubHistory([]);
            setRotationCount(0);
        } : autoArrangePlayers,
        className: `${playMode === 'substitutional' ? 'flex-1' : 'flex-1'} p-3 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition-colors`,
        disabled: playMode === 'rotational' && players.filter(p => p.active).length < 6
    },
        playMode === 'substitutional' ? "🔄 Reset" : "📋 Basic Setup"
    ),
    
    // Manual Setup button for substitutional mode
    playMode === 'substitutional' && (
        React.createElement('button', {
            onClick: () => {
                const activePlayers = players.filter(p => p.active);
                if (activePlayers.length < 6) return;

                const courtPlayers = [];
                const benchPlayers = [];
                
                // Process players in roster order, respecting sub pairings
                const processedPlayers = new Set();
                
                activePlayers.forEach(player => {
                    if (processedPlayers.has(player.id)) return;
                    
                    if (player.subPair) {
                        const partner = players.find(p => p.id === player.subPair);
                        if (partner && !processedPlayers.has(partner.id)) {
                            // For sub pairs, put the better serve receive player on court
                            const courtPlayer = player.serveReceive >= partner.serveReceive ? player : partner;
                            const benchPlayer = courtPlayer === player ? partner : player;
                            
                            if (courtPlayers.length < 6) {
                                courtPlayers.push(courtPlayer);
                                benchPlayers.push(benchPlayer);
                            } else {
                                benchPlayers.push(courtPlayer, benchPlayer);
                            }
                            
                            processedPlayers.add(player.id);
                            processedPlayers.add(partner.id);
                        }
                    } else {
                        // No sub pair - add to court or bench
                        if (courtPlayers.length < 6) {
                            courtPlayers.push(player);
                        } else {
                            benchPlayers.push(player);
                        }
                        processedPlayers.add(player.id);
                    }
                });

                // Fill remaining court spots if needed
                while (courtPlayers.length < 6 && benchPlayers.length > 0) {
                    courtPlayers.push(benchPlayers.shift());
                }

                // Arrange court positions based on serve receive and setting strengths
                if (courtPlayers.length >= 6) {
                    const sortedBySR = [...courtPlayers].sort((a, b) => b.serveReceive - a.serveReceive);
                    const sortedBySetting = [...courtPlayers].sort((a, b) => b.setting - a.setting);
                    
                    const newPositions = {
                        // Back row: best serve receive players
                        backLeft: sortedBySR[0],
                        backMiddle: sortedBySR[1], 
                        backRight: sortedBySR[2],
                        // Front row: best setting players from remaining
                        frontLeft: sortedBySetting.find(p => !sortedBySR.slice(0, 3).includes(p)) || sortedBySetting[3],
                        frontMiddle: sortedBySetting.find(p => !sortedBySR.slice(0, 3).includes(p) && 
                                    p !== (sortedBySetting.find(p => !sortedBySR.slice(0, 3).includes(p)) || sortedBySetting[3])) || sortedBySetting[4],
                        frontRight: courtPlayers.find(p => ![
                            sortedBySR[0], sortedBySR[1], sortedBySR[2],
                            sortedBySetting.find(p => !sortedBySR.slice(0, 3).includes(p)) || sortedBySetting[3],
                            sortedBySetting.find(p => !sortedBySR.slice(0, 3).includes(p) && 
                                p !== (sortedBySetting.find(p => !sortedBySR.slice(0, 3).includes(p)) || sortedBySetting[3])) || sortedBySetting[4]
                        ].includes(p)) || sortedBySetting[5],
                        bench: benchPlayers
                    };
                    
                    setCourtPositions(newPositions);
                    setSubstitutionCount(0);
                    setSubHistory([]);
                    setRotationCount(0);
                }
            },
            className: "flex-1 p-3 bg-cyan-500 text-white rounded-lg hover:bg-cyan-600 transition-colors",
            disabled: players.filter(p => p.active).length < 6
        },
            "⚙️ Manual Setup"
        )
    )
)
                ),

                // Players List
                React.createElement('div', { className: "mb-6" },
                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                        React.createElement('h2', { className: "text-lg font-semibold" }, `Team Roster (${players.length}/12)`),
                        React.createElement('button', {
                            onClick: () => setShowPlayerForm(true),
                            className: "flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
                        },
                            "+ Add Player"
                        )
                    ),
                    
                    React.createElement('div', { className: "space-y-2" },
                        players.map(player => {
                            const subColorClass = player.subColor !== null ? SUB_COLORS[player.subColor] : '';
                            const isNoSub = (playMode === 'substitutional' && player.star) || player.isFullTime;
                            const subPartner = player.subPair ? players.find(p => p.id === player.subPair) : null;
                            
                            return React.createElement('div', { 
                                key: player.id, 
                                className: `flex items-center gap-2 p-2 rounded-lg transition-all ${
                                    isNoSub ? 'no-sub-player' : subColorClass || 'bg-white'
                                } ${!player.active ? 'opacity-50' : ''}`
                            },
                                React.createElement('button', {
                                    onClick: () => togglePlayerActive(player.id),
                                    className: `w-4 h-4 rounded border-2 ${
                                        player.active ? 'bg-green-500 border-green-500' : 'border-gray-300'
                                    }`
                                }),
                                React.createElement('button', {
                                    onClick: () => togglePlayerStar(player.id),
                                    className: `w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                                        player.star ? 'bg-yellow-400 border-yellow-500' : 'border-gray-300 hover:border-yellow-400'
                                    }`,
                                    title: playMode === 'rotational' ? 'Star Player' : 'No Substitution Partner'
                                },
                                    React.createElement('span', { className: "text-xs" }, 
                                        player.star ? '⭐' : '☆'
                                    )
                                ),
                                React.createElement('div', { 
                                    className: "flex-1 cursor-pointer",
                                    onClick: () => handleEditPlayer(player)
                                },
                                    React.createElement('div', { className: "flex items-center justify-between" },
                                        React.createElement('div', { className: "font-semibold text-sm" }, player.name),
                                        React.createElement('div', { className: "flex gap-1" },
                                            subPartner && React.createElement('span', { 
                                                className: "text-xs text-blue-600",
                                                title: `Paired with ${subPartner.name}`
                                            }, '🔗'),
                                            player.isFullTime && React.createElement('span', { 
                                                className: "text-xs text-yellow-600",
                                                title: "Full-time player (no substitutions)"
                                            }, '⭐')
                                        )
                                    ),
                                    React.createElement('div', { className: "text-xs text-gray-600" },
                                        playMode === 'rotational' 
                                            ? `D:${player.defense} S:${player.serving}`
                                            : `S:${player.serving} SR:${player.serveReceive} Set:${player.setting} AA:${player.allAround}`
                                    )
                                ),
                                playMode === 'substitutional' && (
                                    React.createElement('div', { className: "flex gap-1" },
                                        // Color change buttons for sub pairs
                                        !isNoSub && player.subPair && SUB_COLORS.map((colorClass, index) => (
                                            React.createElement('button', {
                                                key: index,
                                                onClick: () => changeSubColor(player.id, index),
                                                className: `w-4 h-4 rounded border ${colorClass} ${
                                                    player.subColor === index ? 'border-2 border-black' : 'border-gray-400'
                                                }`,
                                                title: `Change to color ${index + 1}`
                                            })
                                        )),
                                        // Unpair button
                                        !isNoSub && player.subPair && (
                                            React.createElement('button', {
                                                onClick: () => removeSubPair(player.id),
                                                className: "w-4 h-4 bg-red-500 text-white rounded text-xs flex items-center justify-center",
                                                title: "Remove substitution pairing"
                                            }, "×")
                                        )
                                    )
                                )
                            );
                        })
                    )
                ),
    // Enhanced Player Form Modal with mode-specific attributes
                showPlayerForm && (
                    React.createElement('div', { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" },
                        React.createElement('div', { className: "bg-white rounded-lg p-6 w-80 mx-4 max-h-screen overflow-y-auto" },
                            React.createElement('h3', { className: "text-lg font-semibold mb-4" },
                                editingPlayer ? 'Edit Player' : 'Add New Player'
                            ),
                            
                            React.createElement('div', { className: "space-y-4" },
                                React.createElement('div', {},
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Player Name"),
                                    React.createElement('input', {
                                        type: "text",
                                        value: playerForm.name,
                                        onChange: (e) => setPlayerForm({...playerForm, name: e.target.value}),
                                        className: "w-full p-2 border rounded-lg focus:ring-2 focus:ring-blue-500 outline-none",
                                        placeholder: "Enter player name"
                                    })
                                ),
                                
                                // Defense Rating - Only show in rotational mode
                                playMode === 'rotational' && React.createElement('div', {},
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Defense (1-5)"),
                                    React.createElement('input', {
                                        type: "range",
                                        min: "1",
                                        max: "5",
                                        value: playerForm.defense,
                                        onChange: (e) => setPlayerForm({...playerForm, defense: parseInt(e.target.value)}),
                                        className: "w-full"
                                    }),
                                    React.createElement('div', { className: "text-center font-semibold text-sm" }, playerForm.defense)
                                ),
                                
                                // Serving Rating
                                React.createElement('div', {},
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Serving (1-5)"),
                                    React.createElement('input', {
                                        type: "range",
                                        min: "1",
                                        max: "5",
                                        value: playerForm.serving,
                                        onChange: (e) => setPlayerForm({...playerForm, serving: parseInt(e.target.value)}),
                                        className: "w-full"
                                    }),
                                    React.createElement('div', { className: "text-center font-semibold text-sm" }, playerForm.serving)
                                ),

                                // Serve Receive Rating - Only show in substitutional mode
                                playMode === 'substitutional' && React.createElement('div', {},
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Serve Receive - SR (1-5)"),
                                    React.createElement('input', {
                                        type: "range",
                                        min: "1",
                                        max: "5",
                                        value: playerForm.serveReceive,
                                        onChange: (e) => setPlayerForm({...playerForm, serveReceive: parseInt(e.target.value)}),
                                        className: "w-full"
                                    }),
                                    React.createElement('div', { className: "text-center font-semibold text-sm" }, playerForm.serveReceive)
                                ),

                                // Setting Rating - Only show in substitutional mode
                                playMode === 'substitutional' && React.createElement('div', {},
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Setting (1-5)"),
                                    React.createElement('input', {
                                        type: "range",
                                        min: "1",
                                        max: "5",
                                        value: playerForm.setting,
                                        onChange: (e) => setPlayerForm({...playerForm, setting: parseInt(e.target.value)}),
                                        className: "w-full"
                                    }),
                                    React.createElement('div', { className: "text-center font-semibold text-sm" }, playerForm.setting)
                                ),

                                // All Around Rating - Only show in substitutional mode
                                playMode === 'substitutional' && React.createElement('div', {},
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "All Around (1-5)"),
                                    React.createElement('input', {
                                        type: "range",
                                        min: "1",
                                        max: "5",
                                        value: playerForm.allAround,
                                        onChange: (e) => setPlayerForm({...playerForm, allAround: parseInt(e.target.value)}),
                                        className: "w-full"
                                    }),
                                    React.createElement('div', { className: "text-center font-semibold text-sm" }, playerForm.allAround)
                                ),

                                // Star Player / No Sub Toggle
                                React.createElement('div', { className: "flex items-center gap-2" },
                                    React.createElement('label', { className: "block text-sm font-medium" }, 
                                        playMode === 'rotational' ? 'Star Player' : 'No Substitution Partner'
                                    ),
                                    React.createElement('button', {
                                        onClick: () => setPlayerForm({...playerForm, star: !playerForm.star}),
                                        className: `w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                                            playerForm.star ? 'bg-yellow-400 border-yellow-500' : 'border-gray-300 hover:border-yellow-400'
                                        }`,
                                        type: "button"
                                    },
                                        React.createElement('span', { className: "text-xs" }, 
                                            playerForm.star ? '⭐' : '☆'
                                        )
                                    )
                                )
                            ),
                            
                            React.createElement('div', { className: "flex gap-3 mt-6" },
                                React.createElement('button', {
                                    onClick: () => {
                                        setShowPlayerForm(false);
                                        setEditingPlayer(null);
                                        setPlayerForm({ 
                                            name: '', 
                                            defense: 3, 
                                            serving: 3, 
                                            serveReceive: 3, 
                                            setting: 3, 
                                            allAround: 3, 
                                            active: true, 
                                            star: false 
                                        });
                                    },
                                    className: "flex-1 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50"
                                }, "Cancel"),
                                React.createElement('button', {
                                    onClick: editingPlayer ? handleUpdatePlayer : handleAddPlayer,
                                    className: "flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600",
                                    disabled: !playerForm.name.trim()
                                }, editingPlayer ? 'Update Player' : 'Add Player')
                            )
                        )
                    )
                ),

                // Enhanced Substitution History Panel
                playMode === 'substitutional' && subHistory.length > 0 && (
                    React.createElement('div', { className: "mb-6 p-3 bg-blue-50 border border-blue-200 rounded-lg" },
                        React.createElement('h3', { className: "text-sm font-semibold mb-2 text-blue-800" }, "Recent Substitutions"),
                        React.createElement('div', { className: "space-y-1 max-h-32 overflow-y-auto" },
                            subHistory.slice(-5).map((sub, index) => (
                                React.createElement('div', { key: index, className: "text-xs text-blue-700" },
                                    `R${sub.rotation}: ${sub.out} → ${sub.in} (${sub.reason})`
                                )
                            ))
                        ),
                        React.createElement('button', {
                            onClick: () => {
                                setSubHistory([]);
                                setSubstitutionCount(0);
                                setRotationCount(0);
                            },
                            className: "mt-2 text-xs text-blue-600 hover:text-blue-800"
                        }, "Clear History")
                    )
                ),

              // Enhanced Drag-and-Drop Sub Pairing Tool
playMode === 'substitutional' && (
    React.createElement('div', { className: "mb-6 p-3 bg-purple-50 border border-purple-200 rounded-lg" },
        React.createElement('h3', { className: "text-sm font-semibold mb-2 text-purple-800" }, "Substitution Management"),
        React.createElement('div', { className: "text-xs text-purple-700 mb-2" },
            "Drag unpaired players onto each other to create pairs. Hold and drag pairs to delete icon to unlink."
        ),
        
        // Show current pairing status
        React.createElement('div', { className: "mb-3" },
            React.createElement('div', { className: "text-xs font-medium text-purple-800 mb-1" }, "Current Status:"),
            React.createElement('div', { className: "text-xs text-purple-700" },
                `${players.filter(p => p.star || p.isFullTime).length} No-Sub Players | ${Math.floor(players.filter(p => p.subPair).length / 2)} Sub Pairs | ${players.filter(p => p.active && !p.star && !p.isFullTime && !p.subPair).length} Unpaired`
            )
        ),

        
        // Current pairs display
        Math.floor(players.filter(p => p.subPair).length / 2) > 0 && (
            React.createElement('div', { className: "mb-3" },
                React.createElement('div', { className: "text-xs font-medium text-purple-800 mb-2" }, "Linked Pairs:"),
                React.createElement('div', { className: "flex gap-2 flex-wrap" },
                    // Get unique pairs
                    players.filter(p => p.subPair && p.id < p.subPair).map(player1 => {
                        const player2 = players.find(p => p.id === player1.subPair);
                        if (!player2) return null;
                        
                        const subColorClass = player1.subColor !== null ? SUB_COLORS[player1.subColor] : '';
                        
                        return React.createElement('div', {
                            key: `pair-${player1.id}-${player2.id}`,
                            className: `flex items-center gap-1 p-2 rounded-lg border-2 transition-all ${subColorClass} ${
                                draggedPlayer && (draggedPlayer.id === player1.id || draggedPlayer.id === player2.id) ? 'opacity-50 scale-95' : ''
                            }`,
                        },
                            React.createElement('div', { className: "text-xs font-medium" }, player1.name),
                            React.createElement('div', { className: "text-blue-500 text-xs" }, '🔗'),
                            React.createElement('div', { className: "text-xs font-medium" }, player2.name),
                            React.createElement('button', {
                                onClick: (e) => {
                                    e.stopPropagation();
                                    removeSubPair(player1.id);
                                },
                                className: "ml-2 w-5 h-5 bg-red-500 text-white rounded-full text-xs flex items-center justify-center hover:bg-red-600",
                                title: "Unlink pair"
                            }, "×")
                        );
                    }).filter(Boolean)
                )
            )
        ),
        
        // Unpaired players for drag-and-drop pairing
        players.filter(p => p.active && !p.star && !p.isFullTime && !p.subPair).length > 0 && (
            React.createElement('div', {},
                React.createElement('div', { className: "text-xs font-medium text-purple-800 mb-2" }, "Unpaired Players (drag onto each other to pair):"),
                React.createElement('div', { className: "flex gap-2 flex-wrap" },
                    players.filter(p => p.active && !p.star && !p.isFullTime && !p.subPair).map(player => (
                        React.createElement('div', {
                            key: player.id,
                            className: `p-2 bg-white border-2 border-purple-300 rounded-lg text-xs font-medium cursor-move transition-all hover:bg-purple-50 ${
                                draggedPlayer && draggedPlayer.id === player.id ? 'opacity-50 scale-95' : ''
                            } ${dropZone === `pair-${player.id}` ? 'border-blue-500 bg-blue-50' : ''}`,
                            draggable: true,
                            onDragStart: (e) => {
                                setDraggedPlayer(player);
                                e.dataTransfer.effectAllowed = 'move';
                            },
                            onDragEnd: () => setDraggedPlayer(null),
                            onDragOver: (e) => e.preventDefault(),
                            onDragEnter: (e) => {
                                e.preventDefault();
                                if (draggedPlayer && draggedPlayer.id !== player.id && !draggedPlayer.subPair && !player.subPair) {
                                    setDropZone(`pair-${player.id}`);
                                }
                            },
                            onDragLeave: (e) => {
                                e.preventDefault();
                                setDropZone(null);
                            },
                            onDrop: (e) => {
                                e.preventDefault();
                                setDropZone(null);
                                if (draggedPlayer && draggedPlayer.id !== player.id && !draggedPlayer.subPair && !player.subPair) {
                                    createSubPair(draggedPlayer.id, player.id);
                                    setDraggedPlayer(null);
                                }
                            }
                        },
                            player.name
                        )
                    ))
                )
            )
        ),
        
        players.filter(p => p.active && !p.star && !p.isFullTime && !p.subPair).length === 0 && Math.floor(players.filter(p => p.subPair).length / 2) === 0 && (
            React.createElement('div', { className: "text-xs text-gray-500" }, "All eligible players are paired or designated as no-sub.")
        )
    )
)                         
            );
        };

        ReactDOM.render(React.createElement(VolleyballApp), document.getElementById('root'));
    </script>
</body>
</html>
