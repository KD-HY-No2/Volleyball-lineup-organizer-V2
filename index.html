<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volleyball Lineup Optimizer</title>
    <meta name="description" content="Professional volleyball lineup optimization with rotational and substitutional play modes">
    <meta name="theme-color" content="#8b5cf6">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS specific -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Volleyball Optimizer">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        
        @media (max-width: 768px) {
            html, body {
                height: 100%;
                overflow-x: hidden;
            }
        }

        ::-webkit-scrollbar {
            width: 3px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .drop-zone-active {
            background-color: rgba(59, 130, 246, 0.1) !important;
            border: 2px dashed #3b82f6 !important;
        }

        .optimizing {
            background: linear-gradient(45deg, #8b5cf6, #a855f7);
            animation: pulse 2s infinite;
        }

        .star-player {
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            border-color: #ffd700 !important;
        }

        .no-sub-player {
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            background: linear-gradient(135deg, #ffd700, #ffed4e) !important;
            border: 3px solid #ffd700 !important;
        }

        .sub-color-1 { background-color: #fef3c7 !important; border: 3px solid #f59e0b !important; }
        .sub-color-2 { background-color: #dcfce7 !important; border: 3px solid #22c55e !important; }
        .sub-color-3 { background-color: #dbeafe !important; border: 3px solid #3b82f6 !important; }
        .sub-color-4 { background-color: #f3e8ff !important; border: 3px solid #8b5cf6 !important; }
        .sub-color-5 { background-color: #fce7f3 !important; border: 3px solid #ec4899 !important; }
        .sub-color-6 { background-color: #fef2f2 !important; border: 3px solid #ef4444 !important; }

        .install-prompt {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            animation: slideIn 0.3s ease-out;
        }

        .substitution-counter {
            background: linear-gradient(45deg, #06b6d4, #0891b2);
            color: white;
            font-weight: bold;
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .game-mode-tile {
            background: #f8fafc !important;
            border: 2px solid #e2e8f0 !important;
            position: relative;
            min-height: 80px;
        }

        .stat-bubble {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }

        .stat-bubble:active {
            transform: scale(0.95);
        }

        .stat-bubble.plus-bubble {
            background: #10b981;
            border: 2px solid #059669;
        }

        .stat-bubble.minus-bubble {
            background: #ef4444;
            border: 2px solid #dc2626;
        }

        .stat-counter {
            position: absolute;
            background: #6b7280;
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 10px;
            font-weight: bold;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .stat-animation {
            position: absolute;
            pointer-events: none;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
        }

        .stat-animation.plus-anim {
            color: #10b981;
            animation: floatUp 0.8s ease-out forwards;
        }

        .stat-animation.minus-anim {
            color: #ef4444;
            animation: floatDown 0.8s ease-out forwards;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes slideIn {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }

        @keyframes floatDown {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(30px); opacity: 0; }
        }

        .cursor-move {
            cursor: move;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .cursor-move:active {
            opacity: 0.7;
            transform: scale(0.95);
        }

        @media (hover: none) and (pointer: coarse) {
            .cursor-move {
                -webkit-touch-callout: none;
                -webkit-tap-highlight-color: transparent;
            }
        }

        .game-locked {
            background: linear-gradient(135deg, #fbbf24, #f59e0b) !important;
            border: 2px solid #d97706 !important;
        }

        .cumulative-stats {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            color: #6b7280;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const VolleyballApp = () => {
            // PWA Install State
            const [deferredPrompt, setDeferredPrompt] = useState(null);
            const [showInstallPrompt, setShowInstallPrompt] = useState(false);

            // Game Mode State
            const [gameMode, setGameMode] = useState(false);
            const [gameStats, setGameStats] = useState(() => {
                const saved = localStorage.getItem('volleyball_gameStats');
                return saved ? JSON.parse(saved) : {};
            });

            // Fixed multi-team management with proper slot rotation
            const [teamSlots, setTeamSlots] = useState(() => {
                const saved = localStorage.getItem('volleyball_teamSlots');
                return saved ? JSON.parse(saved) : {
                    active: 'team1',
                    team1: { name: 'Team 1', hasData: false },
                    team2: { name: 'Team 2', hasData: false },
                    team3: { name: 'Team 3', hasData: false }
                };
            });

            // Play Mode State
            const [playMode, setPlayMode] = useState(() => 
                localStorage.getItem(`volleyball_playMode_${teamSlots.active}`) || 'rotational'
            );

            // Load data from localStorage with proper team slot support
            const loadFromStorage = (key, defaultValue) => {
                try {
                    const saved = localStorage.getItem(`${key}_${teamSlots.active}`);
                    return saved ? JSON.parse(saved) : defaultValue;
                } catch (error) {
                    console.warn(`Error loading ${key} from storage:`, error);
                    return defaultValue;
                }
            };

            // Save data to localStorage with proper team slot support
            const saveToStorage = (key, data) => {
                try {
                    localStorage.setItem(`${key}_${teamSlots.active}`, JSON.stringify(data));
                    // Mark team as having data
                    setTeamSlots(prev => {
                        const updated = {
                            ...prev,
                            [prev.active]: { ...prev[prev.active], hasData: true }
                        };
                        localStorage.setItem('volleyball_teamSlots', JSON.stringify(updated));
                        return updated;
                    });
                } catch (error) {
                    console.warn(`Error saving ${key} to storage:`, error);
                }
            };
          // Enhanced player data structure
            const [optimizationStrategy, setOptimizationStrategy] = useState(0);
            const [players, setPlayers] = useState(() => {
                const saved = localStorage.getItem(`volleyball_players_${teamSlots.active}`);
                if (saved) {
                    const parsedPlayers = JSON.parse(saved);
                    return parsedPlayers.map(p => ({
                        ...p,
                        serveReceive: p.serveReceive || 3,
                        setting: p.setting || 3,
                        allAround: p.allAround || 3,
                        subPair: p.subPair || null,
                        subColor: p.subColor || null,
                        isFullTime: p.isFullTime || false
                    }));
                }
                return [
                    { id: 1, name: '1', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 2, name: '2', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 3, name: '3', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 4, name: '4', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 5, name: '5', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 6, name: '6', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 7, name: '7', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 8, name: '8', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 9, name: '9', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                    { id: 10, name: '10', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false }
                ];
            });

            // Enhanced substitution tracking
            const [substitutionCount, setSubstitutionCount] = useState(0);
            const [subHistory, setSubHistory] = useState([]);
            const [rotationCount, setRotationCount] = useState(0);

            const [showPlayerForm, setShowPlayerForm] = useState(false);
            const [editingPlayer, setEditingPlayer] = useState(null);
            const [teamName, setTeamName] = useState(() => loadFromStorage('volleyball_teamName', teamSlots[teamSlots.active].name));
            const [minThreshold, setMinThreshold] = useState(() => loadFromStorage('volleyball_minThreshold', 6));
            const [isOptimizing, setIsOptimizing] = useState(false);
            const [draggedPlayer, setDraggedPlayer] = useState(null);
            const [dropZone, setDropZone] = useState(null);
            const [bestLineups, setBestLineups] = useState([]);
            const [currentLineupIndex, setCurrentLineupIndex] = useState(0);

            // Add these new state variables
const [showGameHistory, setShowGameHistory] = useState(false);
const [selectedHistoryGame, setSelectedHistoryGame] = useState(null);
            
            // Enhanced form state with mode-specific attributes
            const [playerForm, setPlayerForm] = useState({
                name: '',
                defense: 3,
                serving: 3,
                serveReceive: 3,
                setting: 3,
                allAround: 3,
                active: true,
                star: false
            });

            // Court positions
            const [courtPositions, setCourtPositions] = useState(() => 
                loadFromStorage('volleyball_courtPositions', {
                    backLeft: null,
                    frontLeft: null,
                    frontMiddle: null,
                    frontRight: null,
                    backRight: null,
                    backMiddle: null,
                    bench: []
                })
            );

            // Game Stats Management
            const getCurrentGameStats = () => {
                const teamKey = teamSlots.active;
                if (!gameStats[teamKey]) return null;
                
                const currentGameId = gameStats[teamKey].currentGame;
                if (!currentGameId) return null;
                
                return gameStats[teamKey].games.find(g => g.id === currentGameId);
            };

            const getPlayerGameStat = (playerId, category, type) => {
                const currentGame = getCurrentGameStats();
                if (!currentGame || !currentGame.playerStats[playerId]) return 0;
                return currentGame.playerStats[playerId][category][type] || 0;
            };

            const updatePlayerGameStat = (playerId, category, type) => {
                const teamKey = teamSlots.active;
                
                setGameStats(prev => {
                    const updated = { ...prev };
                    
                    // Initialize team stats if needed
                    if (!updated[teamKey]) {
                        updated[teamKey] = { games: [], currentGame: null };
                    }
                    
                    // Initialize current game if needed
                    if (!updated[teamKey].currentGame) {
                        const newGameId = Date.now();
                        // Generate sequential game number for this team
const gameNumber = (updated[teamKey].games?.length || 0) + 1;
const gameDate = new Date().toISOString().split('T')[0];

updated[teamKey].games.push({
    id: newGameId,
    name: `Game ${gameNumber} - ${gameDate}`,
    date: gameDate,
    locked: false,
    playerStats: {}
});
                        updated[teamKey].currentGame = newGameId;
                    }
                    
                    const currentGameId = updated[teamKey].currentGame;
                    const gameIndex = updated[teamKey].games.findIndex(g => g.id === currentGameId);
                    
                    if (gameIndex >= 0) {
                        // Initialize player stats if needed
                        if (!updated[teamKey].games[gameIndex].playerStats[playerId]) {
                            updated[teamKey].games[gameIndex].playerStats[playerId] = {
                                defense: { success: 0, miss: 0 },
                                serving: { success: 0, miss: 0 }
                            };
                        }
                        
                        // Update the specific stat
                        updated[teamKey].games[gameIndex].playerStats[playerId][category][type]++;
                    }
                    // Add this line:
addToUndoHistory(playerId, category, type);
                    
                    // Save to localStorage
                    localStorage.setItem('volleyball_gameStats', JSON.stringify(updated));
                    
                    return updated;
                });
                
                // Trigger haptic feedback if available
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            };

// Undo history tracking
const [undoHistory, setUndoHistory] = useState([]);

const addToUndoHistory = (playerId, category, type) => {
    setUndoHistory(prev => {
        const newHistory = [...prev, {
            timestamp: Date.now(),
            playerId,
            category,
            type,
            gameId: getCurrentGameStats()?.id
        }];
        // Keep only last 20 actions for performance
        return newHistory.slice(-20);
    });
};

const undoLastAction = () => {
    if (undoHistory.length === 0) return;
    
    const currentGame = getCurrentGameStats();
    if (!currentGame || currentGame.locked) return;
    
    const lastAction = undoHistory[undoHistory.length - 1];
    
    // Only undo if it's from the current game
    if (lastAction.gameId !== currentGame.id) return;
    
    const teamKey = teamSlots.active;
    
    setGameStats(prev => {
        const updated = { ...prev };
        const gameIndex = updated[teamKey].games.findIndex(g => g.id === currentGame.id);
        
        if (gameIndex >= 0 && updated[teamKey].games[gameIndex].playerStats[lastAction.playerId]) {
            const playerStats = updated[teamKey].games[gameIndex].playerStats[lastAction.playerId];
            if (playerStats[lastAction.category] && playerStats[lastAction.category][lastAction.type] > 0) {
                playerStats[lastAction.category][lastAction.type]--;
            }
        }
        
        localStorage.setItem('volleyball_gameStats', JSON.stringify(updated));
        return updated;
    });
    
    // Remove the undone action from history
    setUndoHistory(prev => prev.slice(0, -1));
    
    // Trigger haptic feedback
    if (navigator.vibrate) {
        navigator.vibrate([50, 50, 50]);
    }
};
            const getCumulativeStats = (playerId, category, type) => {
                const teamKey = teamSlots.active;
                if (!gameStats[teamKey]) return 0;
                
                return gameStats[teamKey].games
                    .filter(game => game.locked)
                    .reduce((total, game) => {
                        if (game.playerStats[playerId] && game.playerStats[playerId][category]) {
                            return total + (game.playerStats[playerId][category][type] || 0);
                        }
                        return total;
                    }, 0);
            };
          // Animation references
            const animationRefs = useRef(new Map());

            const triggerStatAnimation = (playerId, position, type) => {
                const element = document.querySelector(`[data-player-id="${playerId}"]`);
                if (!element) return;
                
                const rect = element.getBoundingClientRect();
                const animationId = `${playerId}-${Date.now()}`;
                
                const animation = document.createElement('div');
                animation.className = `stat-animation ${type === 'success' ? 'plus-anim' : 'minus-anim'}`;
                animation.textContent = type === 'success' ? '+' : '✗';
                animation.style.position = 'fixed';
                animation.style.left = `${rect.left + rect.width / 2}px`;
                animation.style.top = `${rect.top + rect.height / 2}px`;
                animation.style.zIndex = '1000';
                
                document.body.appendChild(animation);
                
                setTimeout(() => {
                    if (animation.parentNode) {
                        animation.parentNode.removeChild(animation);
                    }
                }, 800);
            };
          // Fixed team switching with proper slot rotation
            const switchTeam = (targetSlot) => {
                // Save current team data before switching
                saveToStorage('volleyball_players', players);
                saveToStorage('volleyball_teamName', teamName);
                saveToStorage('volleyball_minThreshold', minThreshold);
                saveToStorage('volleyball_courtPositions', courtPositions);
                localStorage.setItem(`volleyball_playMode_${teamSlots.active}`, playMode);
                
                // Update team name in slots
                const currentActiveSlot = teamSlots.active;
                const updatedSlots = {
                    ...teamSlots,
                    active: targetSlot,
                    [currentActiveSlot]: { ...teamSlots[currentActiveSlot], name: teamName, hasData: true }
                };
                
                setTeamSlots(updatedSlots);
                localStorage.setItem('volleyball_teamSlots', JSON.stringify(updatedSlots));
                
                // Load target team data
                const targetTeamData = localStorage.getItem(`volleyball_players_${targetSlot}`);
                if (targetTeamData) {
                    const parsedPlayers = JSON.parse(targetTeamData);
                    setPlayers(parsedPlayers.map(p => ({
                        ...p,
                        serveReceive: p.serveReceive || 3,
                        setting: p.setting || 3,
                        allAround: p.allAround || 3,
                        subPair: p.subPair || null,
                        subColor: p.subColor || null,
                        isFullTime: p.isFullTime || false
                    })));
                } else {
                    setPlayers([
                        { id: 1, name: '1', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 2, name: '2', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 3, name: '3', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 4, name: '4', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 5, name: '5', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 6, name: '6', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 7, name: '7', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 8, name: '8', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 9, name: '9', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false },
                        { id: 10, name: '10', defense: 3, serving: 3, serveReceive: 3, setting: 3, allAround: 3, active: true, star: false, subPair: null, subColor: null, isFullTime: false }
                    ]);
                }
                
                // Load other team-specific data
                const targetTeamName = localStorage.getItem(`volleyball_teamName_${targetSlot}`);
                setTeamName(targetTeamName ? JSON.parse(targetTeamName) : updatedSlots[targetSlot].name);
                
                const targetMinThreshold = localStorage.getItem(`volleyball_minThreshold_${targetSlot}`);
                setMinThreshold(targetMinThreshold ? JSON.parse(targetMinThreshold) : 6);
                
                const targetCourtPositions = localStorage.getItem(`volleyball_courtPositions_${targetSlot}`);
                setCourtPositions(targetCourtPositions ? JSON.parse(targetCourtPositions) : {
                    backLeft: null, frontLeft: null, frontMiddle: null,
                    frontRight: null, backRight: null, backMiddle: null, bench: []
                });
                
                const targetPlayMode = localStorage.getItem(`volleyball_playMode_${targetSlot}`);
                setPlayMode(targetPlayMode || 'rotational');
                
                // Reset optimization and substitution state
                setBestLineups([]);
                setCurrentLineupIndex(0);
                setSubstitutionCount(0);
                setSubHistory([]);
                setRotationCount(0);
            };

            // Game Management Functions
            const toggleGameMode = () => {
                if (gameMode) {
                    // Exiting game mode - ensure game is locked
                    lockCurrentGame();
                }
                setGameMode(!gameMode);
            };

            const startNewGame = () => {
                // Lock current game if exists
                lockCurrentGame();
                // Create new game
                const teamKey = teamSlots.active;
                const newGameId = Date.now();
                
                setGameStats(prev => {
                    const updated = { ...prev };
                    
                    if (!updated[teamKey]) {
                        updated[teamKey] = { games: [], currentGame: null };
                    }
                    
                    // Generate sequential game number for this team
const gameNumber = updated[teamKey].games.length + 1;
const gameDate = new Date().toISOString().split('T')[0];

updated[teamKey].games.push({
    id: newGameId,
    name: `Game ${gameNumber} - ${gameDate}`,
    date: gameDate,
    locked: false,
    playerStats: {}
});
                    updated[teamKey].currentGame = newGameId;
                    
                    localStorage.setItem('volleyball_gameStats', JSON.stringify(updated));
                    return updated;
                });
            };

            const lockCurrentGame = () => {
                const teamKey = teamSlots.active;
                const currentGame = getCurrentGameStats();
                
                if (!currentGame || currentGame.locked) return;
                
                setGameStats(prev => {
                    const updated = { ...prev };
                    const gameIndex = updated[teamKey].games.findIndex(g => g.id === currentGame.id);
                    
                    if (gameIndex >= 0) {
                        updated[teamKey].games[gameIndex].locked = true;
                    }
                    
                    localStorage.setItem('volleyball_gameStats', JSON.stringify(updated));
                    return updated;
                });
            };

            const unlockCurrentGame = () => {
                const teamKey = teamSlots.active;
                const currentGame = getCurrentGameStats();
                
                if (!currentGame || !currentGame.locked) return;
                
                if (confirm('Are you sure you want to unlock this game? This will allow stats to be modified.')) {
                    setGameStats(prev => {
                        const updated = { ...prev };
                        const gameIndex = updated[teamKey].games.findIndex(g => g.id === currentGame.id);
                        
                        if (gameIndex >= 0) {
                            updated[teamKey].games[gameIndex].locked = false;
                        }
                        
                        localStorage.setItem('volleyball_gameStats', JSON.stringify(updated));
                        return updated;
                    });
                }
            };

            const getTeamTotals = (category, type) => {
                const activePlayers = players.filter(p => p.active);
                return activePlayers.reduce((total, player) => {
                    return total + getPlayerGameStat(player.id, category, type);
                }, 0);
            };

           // Game History Functions
const getGameHistory = () => {
    const teamKey = teamSlots.active;
    if (!gameStats[teamKey]) return [];
    
    return gameStats[teamKey].games
        .filter(game => game.locked)
        .sort((a, b) => new Date(b.date) - new Date(a.date)); // Most recent first
};

const getPlayerStatsForGame = (gameId, playerId) => {
    const teamKey = teamSlots.active;
    if (!gameStats[teamKey]) return { defense: { success: 0, miss: 0 }, serving: { success: 0, miss: 0 } };
    
    const game = gameStats[teamKey].games.find(g => g.id === gameId);
    if (!game || !game.playerStats[playerId]) {
        return { defense: { success: 0, miss: 0 }, serving: { success: 0, miss: 0 } };
    }
    
    return game.playerStats[playerId];
};

const getGameTotalsForGame = (gameId, category, type) => {
    const activePlayers = players.filter(p => p.active);
    return activePlayers.reduce((total, player) => {
        const stats = getPlayerStatsForGame(gameId, player.id);
        return total + (stats[category][type] || 0);
    }, 0);
}; 

            const deleteGame = (gameId) => {
    const teamKey = teamSlots.active;
    
    if (confirm('Are you sure you want to delete this game? This action cannot be undone.')) {
        setGameStats(prev => {
            const updated = { ...prev };
            
            if (updated[teamKey] && updated[teamKey].games) {
                // Remove the game from the games array
                updated[teamKey].games = updated[teamKey].games.filter(g => g.id !== gameId);
                
                // If this was the current game, clear the current game reference
                if (updated[teamKey].currentGame === gameId) {
                    updated[teamKey].currentGame = null;
                }
                
                localStorage.setItem('volleyball_gameStats', JSON.stringify(updated));
            }
            
            return updated;
        });
        
        // Close the individual game view if we're viewing the deleted game
        if (selectedHistoryGame && selectedHistoryGame.id === gameId) {
            setSelectedHistoryGame(null);
        }
    }
};
            // Save to localStorage whenever data changes
            useEffect(() => {
                saveToStorage('volleyball_players', players);
            }, [players]);

            useEffect(() => {
                saveToStorage('volleyball_teamName', teamName);
                // Update team name in slots
                setTeamSlots(prev => {
                    const updated = {
                        ...prev,
                        [prev.active]: { ...prev[prev.active], name: teamName }
                    };
                    localStorage.setItem('volleyball_teamSlots', JSON.stringify(updated));
                    return updated;
                });
            }, [teamName]);

            useEffect(() => {
                saveToStorage('volleyball_minThreshold', minThreshold);
            }, [minThreshold]);

            useEffect(() => {
                saveToStorage('volleyball_courtPositions', courtPositions);
            }, [courtPositions]);

            useEffect(() => {
                localStorage.setItem(`volleyball_playMode_${teamSlots.active}`, playMode);
            }, [playMode, teamSlots.active]);

            // Auto-save game stats periodically
            useEffect(() => {
                if (!gameMode) return;
                
                const autoSave = setInterval(() => {
                    localStorage.setItem('volleyball_gameStats', JSON.stringify(gameStats));
                }, 10000); // Save every 10 seconds
                
                return () => clearInterval(autoSave);
            }, [gameMode, gameStats]);

            // PWA Install Prompt Handling
            useEffect(() => {
                const handleBeforeInstallPrompt = (e) => {
                    e.preventDefault();
                    setDeferredPrompt(e);
                    setShowInstallPrompt(true);
                };

                const handleAppInstalled = () => {
                    setShowInstallPrompt(false);
                    setDeferredPrompt(null);
                };

                window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
                window.addEventListener('appinstalled', handleAppInstalled);

                return () => {
                    window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
                    window.removeEventListener('appinstalled', handleAppInstalled);
                };
            }, []);

            // Register Service Worker
            useEffect(() => {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('./sw.js')
                        .then((registration) => {
                            console.log('SW registered: ', registration);
                        })
                        .catch((registrationError) => {
                            console.log('SW registration failed: ', registrationError);
                        });
                }
            }, []);

            const handleInstallClick = async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    if (outcome === 'accepted') {
                        setShowInstallPrompt(false);
                    }
                    setDeferredPrompt(null);
                }
            };
          // Enhanced color assignment utility with better contrast
            const SUB_COLORS = ['sub-color-1', 'sub-color-2', 'sub-color-3', 'sub-color-4', 'sub-color-5', 'sub-color-6'];

            // Get available sub colors
            const getAvailableSubColors = () => {
                const usedColors = new Set(players.map(p => p.subColor).filter(p => p !== null));
                return SUB_COLORS.filter((_, index) => !usedColors.has(index));
            };

            // Enhanced player management functions
            const handleAddPlayer = () => {
                if (playerForm.name.trim()) {
                    const newPlayer = {
                        id: Date.now(),
                        ...playerForm,
                        subPair: null,
                        subColor: null,
                        isFullTime: false
                    };
                    setPlayers([...players, newPlayer]);
                    setPlayerForm({ 
                        name: '', 
                        defense: 3, 
                        serving: 3, 
                        serveReceive: 3, 
                        setting: 3, 
                        allAround: 3, 
                        active: true, 
                        star: false 
                    });
                    setShowPlayerForm(false);
                }
            };

            const handleEditPlayer = (player) => {
                if (draggedPlayer) return;
                setEditingPlayer(player.id);
                setPlayerForm({
                    name: player.name,
                    defense: player.defense,
                    serving: player.serving,
                    serveReceive: player.serveReceive || 3,
                    setting: player.setting || 3,
                    allAround: player.allAround || 3,
                    active: player.active,
                    star: player.star
                });
                setShowPlayerForm(true);
            };

            const handleUpdatePlayer = () => {
                setPlayers(players.map(p => 
                    p.id === editingPlayer ? { 
                        ...p, 
                        name: playerForm.name,
                        defense: playerForm.defense,
                        serving: playerForm.serving,
                        serveReceive: playerForm.serveReceive,
                        setting: playerForm.setting,
                        allAround: playerForm.allAround,
                        active: playerForm.active,
                        star: playerForm.star
                    } : p
                ));
                setEditingPlayer(null);
                setPlayerForm({ 
                    name: '', 
                    defense: 3, 
                    serving: 3, 
                    serveReceive: 3, 
                    setting: 3, 
                    allAround: 3, 
                    active: true, 
                    star: false 
                });
                setShowPlayerForm(false);
            };

            const togglePlayerActive = (id) => {
                setPlayers(players.map(p => 
                    p.id === id ? { ...p, active: !p.active } : p
                ));
            };

            const togglePlayerStar = (id) => {
                const currentStars = players.filter(p => p.star).length;
                const targetPlayer = players.find(p => p.id === id);
                
                if (!targetPlayer.star && currentStars >= 3) {
                    return;
                }
                
                setPlayers(players.map(p => 
                    p.id === id ? { ...p, star: !p.star } : p
                ));
            };
          // Fixed substitution pairing functions with proper color assignment
            const createSubPair = (player1Id, player2Id) => {
                const availableColors = getAvailableSubColors();
                if (availableColors.length === 0) return false;

                const colorIndex = SUB_COLORS.indexOf(availableColors[0]);

                setPlayers(prev => prev.map(p => {
                    if (p.id === player1Id || p.id === player2Id) {
                        return { 
                            ...p, 
                            subPair: p.id === player1Id ? player2Id : player1Id,
                            subColor: colorIndex,
                            isFullTime: false
                        };
                    }
                    return p;
                }));
                return true;
            };

            const removeSubPair = (playerId) => {
                const player = players.find(p => p.id === playerId);
                if (!player || !player.subPair) return;

                const pairId = player.subPair;
                setPlayers(prev => prev.map(p => {
                    if (p.id === playerId || p.id === pairId) {
                        return { ...p, subPair: null, subColor: null, isFullTime: false };
                    }
                    return p;
                }));
            };

            const changeSubColor = (playerId, newColorIndex) => {
                const player = players.find(p => p.id === playerId);
                if (!player || !player.subPair) return;

                const pairId = player.subPair;
                setPlayers(prev => prev.map(p => {
                    if (p.id === playerId || p.id === pairId) {
                        return { ...p, subColor: newColorIndex };
                    }
                    return p;
                }));
            };

            // Check if a position is in back row
            const isBackRowPosition = (position) => {
                return ['backLeft', 'backMiddle', 'backRight'].includes(position);
            };

            // Determine which players should be full-time (no subs) based on roster size
            const determineFullTimePlayers = (activePlayers) => {
                if (activePlayers.length <= 6) {
                    // Not enough players for any subs - all are full-time
                    return activePlayers.map(p => p.id);
                }
                
                const availableForPairing = activePlayers.length - (activePlayers.filter(p => p.star).length);
                const needFullTime = availableForPairing % 2; // Odd number means someone needs to be full-time
                
                if (needFullTime === 0) return [];
                
                // Select highest all-around rated players as full-time
                const sortedByAllAround = activePlayers
                    .filter(p => !p.star) // Stars are already marked as no-sub
                    .sort((a, b) => b.allAround - a.allAround);
                    
                return sortedByAllAround.slice(0, needFullTime).map(p => p.id);
            };

            // Strategy definitions (expandable for future)
            const SUBSTITUTIONAL_STRATEGIES = [
                { id: 0, name: 'Separate Lowest Players', description: 'Places lowest 2 players in different pairs' },
                { id: 1, name: 'Pair Lowest Players', description: 'Places lowest 2 players in same pair' }
            ];
          // Helper function to optimize court positions
            const optimizeCourtPositions = (courtPlayers, unpairedPlayers) => {
                // Special handling for exactly 2 unpaired players
                if (unpairedPlayers.length === 2) {
                    const paired = courtPlayers.filter(p => !unpairedPlayers.some(up => up.id === p.id));
                    const unpaired1 = unpairedPlayers[0];
                    const unpaired2 = unpairedPlayers[1];
                    
                    // Try different arrangements where unpaired players are 3 positions apart
                    const validArrangements = [
                        // unpaired1 at position 0 (backLeft), unpaired2 at position 3 (frontRight)
                        [unpaired1, paired[0], paired[1], unpaired2, paired[2], paired[3]],
                        // unpaired1 at position 1 (frontLeft), unpaired2 at position 4 (backRight)
                        [paired[0], unpaired1, paired[1], paired[2], unpaired2, paired[3]],
                        // unpaired1 at position 2 (frontMiddle), unpaired2 at position 5 (backMiddle)
                        [paired[0], paired[1], unpaired1, paired[2], paired[3], unpaired2]
                    ];
                    
                    let bestPositions = null;
                    let bestMinSR = -1;
                    
                    for (const arrangement of validArrangements) {
                        const testPositions = {
                            backLeft: arrangement[0],
                            frontLeft: arrangement[1],
                            frontMiddle: arrangement[2],
                            frontRight: arrangement[3],
                            backRight: arrangement[4],
                            backMiddle: arrangement[5]
                        };
                        
                        const minSR = calculateMinBackRowSR(testPositions);
                        if (minSR > bestMinSR) {
                            bestMinSR = minSR;
                            bestPositions = testPositions;
                        }
                    }
                    
                    return bestPositions || {
                        backLeft: courtPlayers[0],
                        frontLeft: courtPlayers[1],
                        frontMiddle: courtPlayers[2],
                        frontRight: courtPlayers[3],
                        backRight: courtPlayers[4],
                        backMiddle: courtPlayers[5]
                    };
                }
                
                // Original logic for other cases
                let bestPositions = null;
                let bestMinSR = -1;

                for (let startPos = 0; startPos < 6; startPos++) {
                    const testPositions = {
                        backLeft: courtPlayers[startPos % 6],
                        frontLeft: courtPlayers[(startPos + 1) % 6],
                        frontMiddle: courtPlayers[(startPos + 2) % 6],
                        frontRight: courtPlayers[(startPos + 3) % 6],
                        backRight: courtPlayers[(startPos + 4) % 6],
                        backMiddle: courtPlayers[(startPos + 5) % 6]
                    };

                    if (!checkUnpairedPositioning(testPositions, unpairedPlayers)) {
                        continue;
                    }

                    const minSR = calculateMinBackRowSR(testPositions);
                    
                    if (minSR > bestMinSR) {
                        bestMinSR = minSR;
                        bestPositions = testPositions;
                    }
                }

                if (!bestPositions) {
                    bestPositions = {
                        backLeft: courtPlayers[0],
                        frontLeft: courtPlayers[1],
                        frontMiddle: courtPlayers[2],
                        frontRight: courtPlayers[3],
                        backRight: courtPlayers[4],
                        backMiddle: courtPlayers[5]
                    };
                }

                return bestPositions;
            };
          // Helper function to check unpaired player positioning
            const checkUnpairedPositioning = (positions, unpairedPlayers) => {
                if (unpairedPlayers.length !== 2) return true; // Only enforce for exactly 2 unpaired

                const positionArray = [
                    positions.backLeft,    // position 0
                    positions.frontLeft,   // position 1  
                    positions.frontMiddle, // position 2
                    positions.frontRight,  // position 3
                    positions.backRight,   // position 4
                    positions.backMiddle   // position 5
                ];

                const unpairedPositions = [];
                positionArray.forEach((player, index) => {
                    if (player && unpairedPlayers.some(up => up.id === player.id)) {
                        unpairedPositions.push(index);
                    }
                });

                if (unpairedPositions.length === 2) {
                    const pos1 = unpairedPositions[0];
                    const pos2 = unpairedPositions[1];
                    
                    // Check if they are in opposite rows (3 positions apart)
                    // Valid pairs: (0,3), (1,4), (2,5) - exactly 3 positions apart
                    const diff = Math.abs(pos1 - pos2);
                    return diff === 3;
                }

                return true;
            };

            // Helper function to calculate minimum back row SR across rotations
            const calculateMinBackRowSR = (startPositions) => {
                let minSR = Infinity;
                let currentPositions = { ...startPositions };

                for (let rotation = 0; rotation < 6; rotation++) {
                    const backRowSR = (currentPositions.backLeft?.serveReceive || 0) +
                                     (currentPositions.backMiddle?.serveReceive || 0) +
                                     (currentPositions.backRight?.serveReceive || 0);
                    
                    minSR = Math.min(minSR, backRowSR);

                    // Rotate positions
                    const newPositions = {
                        backRight: currentPositions.backMiddle,
                        frontRight: currentPositions.backRight,
                        frontMiddle: currentPositions.frontRight,
                        frontLeft: currentPositions.frontMiddle,
                        backLeft: currentPositions.frontLeft,
                        backMiddle: currentPositions.backLeft
                    };
                    currentPositions = newPositions;
                }

                return minSR;
            };

            // Complete replacement for optimizeSubstitutionalPlay function
            const optimizeSubstitutionalPlay = async () => {
                setIsOptimizing(true);
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const activePlayers = players.filter(p => p.active);
                
                if (activePlayers.length < 6) {
                    alert("Need at least 6 active players for optimization.");
                    setIsOptimizing(false);
                    return;
                }

                // Clear existing pairs and markings
                const updatedPlayers = [...players];
                updatedPlayers.forEach(p => {
                    if (p.active) {
                        p.subPair = null;
                        p.subColor = null;
                        p.isFullTime = false;
                        p.star = false;
                    }
                });

                // Step 1: Rank players by overall rating (allAround score)
                const rankedPlayers = [...activePlayers].sort((a, b) => b.allAround - a.allAround);
                
                // Step 2: Determine unpaired (full-time) players - FIXED LOGIC
                const numPlayers = activePlayers.length;
                let numUnpaired;
                let numPairs;

                if (numPlayers <= 6) {
                    numUnpaired = numPlayers; // Everyone is unpaired (not enough for subs)
                    numPairs = 0;
                } else {
                    // Calculate how many pairs we can make while keeping 6 on court
                    // For 10 players: want 2 unpaired + 4 pairs = 6 on court
                    // For 8 players: want 2 unpaired + 3 pairs = 5 on court... wait that's wrong
                    
                    // Correct approach: 6 must be on court always
                    // If we have N players, we want (6-unpaired) pairs, where each pair contributes 1 to court
                    // So: unpaired + pairs = 6, and pairs*2 + unpaired = N
                    // Solving: pairs = N-6, unpaired = 6-pairs = 12-N
                    
                    if (numPlayers === 7) {
                        numUnpaired = 5; numPairs = 1; // 5 unpaired + 1 pair = 6 on court
                    } else if (numPlayers === 8) {
                        numUnpaired = 4; numPairs = 2; // 4 unpaired + 2 pairs = 6 on court  
                    } else if (numPlayers === 9) {
                        numUnpaired = 3; numPairs = 3; // 3 unpaired + 3 pairs = 6 on court
                    } else if (numPlayers === 10) {
                        numUnpaired = 2; numPairs = 4; // 2 unpaired + 4 pairs = 6 on court
                    } else if (numPlayers === 11) {
                        numUnpaired = 1; numPairs = 5; // 1 unpaired + 5 pairs = 6 on court
                    } else if (numPlayers >= 12) {
                        numUnpaired = 0; numPairs = 6; // 0 unpaired + 6 pairs = 6 on court
                    }
                }

                // Step 3: Mark unpaired players
                const unpairedPlayers = rankedPlayers.slice(0, numUnpaired);
                unpairedPlayers.forEach(player => {
                    const updatedPlayer = updatedPlayers.find(p => p.id === player.id);
                    if (updatedPlayer) {
                        updatedPlayer.star = true;
                        updatedPlayer.isFullTime = true;
                    }
                });

                // Step 4: Create pairs from remaining players - FIXED
                const pairablePlayers = rankedPlayers.slice(numUnpaired);
                const pairs = [];

                // Only create pairs if we have players to pair
                if (numPairs > 0 && pairablePlayers.length >= 2) {
                    // Strategy-specific pairing logic
                    if (optimizationStrategy === 0) {
                        // Strategy 1: Separate lowest 2 players into different pairs
                        if (pairablePlayers.length >= 4 && numPairs >= 2) {
                            const lowestPlayer = pairablePlayers[pairablePlayers.length - 1];
                            const secondLowestPlayer = pairablePlayers[pairablePlayers.length - 2];
                            
                            // Remove lowest players from main pairing pool
                            const mainPairingPool = pairablePlayers.slice(0, -2);
                            
                            // Sort remaining by serve receive for pairing with lowest players
                            const srSorted = mainPairingPool.sort((a, b) => b.serveReceive - a.serveReceive);
                            
                            // Pair each low player with a high SR player
                            if (srSorted.length >= 2) {
                                pairs.push([lowestPlayer, srSorted[0]]);
                                pairs.push([secondLowestPlayer, srSorted[1]]);
                                
                                // Pair remaining players up to numPairs
                                const remaining = srSorted.slice(2);
                                for (let i = 0; i < remaining.length - 1 && pairs.length < numPairs; i += 2) {
                                    pairs.push([remaining[i], remaining[i + 1]]);
                                }
                            }
                        } else {
                            // Fall back to basic pairing
                            for (let i = 0; i < pairablePlayers.length - 1 && pairs.length < numPairs; i += 2) {
                                pairs.push([pairablePlayers[i], pairablePlayers[i + 1]]);
                            }
                        }
                    } else {
                        // Strategy 2: Pair lowest 2 players together
                        if (pairablePlayers.length >= 2) {
                            const lowestPlayer = pairablePlayers[pairablePlayers.length - 1];
                            const secondLowestPlayer = pairablePlayers[pairablePlayers.length - 2];
                            
                            pairs.push([lowestPlayer, secondLowestPlayer]);
                            
                            // Pair remaining players optimally up to numPairs
                            const remaining = pairablePlayers.slice(0, -2);
                            for (let i = 0; i < remaining.length - 1 && pairs.length < numPairs; i += 2) {
                                pairs.push([remaining[i], remaining[i + 1]]);
                            }
                        }
                    }
                }
          // Step 5: Apply color coding to pairs
                pairs.forEach(([player1, player2], index) => {
                    const colorIndex = index % SUB_COLORS.length;
                    
                    const p1 = updatedPlayers.find(p => p.id === player1.id);
                    const p2 = updatedPlayers.find(p => p.id === player2.id);
                    
                    if (p1 && p2) {
                        p1.subPair = player2.id;
                        p1.subColor = colorIndex;
                        p2.subPair = player1.id;
                        p2.subColor = colorIndex;
                    }
                });

                // Step 6: Generate optimal starting lineup
                const courtPlayers = [];
                const benchPlayers = [];

                // Add all unpaired players first
                courtPlayers.push(...unpairedPlayers);

               // Add one player from each pair - temporarily add both, we'll optimize positions later
                const processedPairs = new Set();
                const pairCandidates = [];

                updatedPlayers.forEach(player => {
                    if (player.active && player.subPair && !processedPairs.has(player.id)) {
                        const partner = updatedPlayers.find(p => p.id === player.subPair);
                        if (partner) {
                            processedPairs.add(player.id);
                            processedPairs.add(partner.id);
                            pairCandidates.push({ player1: player, player2: partner });
                        }
                    }
                });

                // Fill remaining court spots with highest rated available
                const remainingPlayers = updatedPlayers.filter(p => 
                    p.active && !courtPlayers.includes(p) && !pairCandidates.some(pair => 
                        pair.player1.id === p.id || pair.player2.id === p.id)
                );
                const sortedRemaining = remainingPlayers.sort((a, b) => b.allAround - a.allAround);

                while (courtPlayers.length < 6 && (pairCandidates.length > 0 || sortedRemaining.length > 0)) {
                    if (pairCandidates.length > 0) {
                        const pair = pairCandidates.shift();
                        courtPlayers.push(pair.player1); // Temporarily add player1, will optimize below
                        benchPlayers.push(pair.player2);
                    } else if (sortedRemaining.length > 0) {
                        courtPlayers.push(sortedRemaining.shift());
                    }
                }
   // Add remaining candidates to bench
                pairCandidates.forEach(pair => {
                    benchPlayers.push(pair.player1, pair.player2);
                });
                benchPlayers.push(...sortedRemaining);

                setPlayers(updatedPlayers);

                // Step 7: Intelligently assign court positions based on player strengths
                if (courtPlayers.length >= 6) {
                    // First, create initial position assignments
                    const initialPositions = optimizeCourtPositions(courtPlayers, unpairedPlayers);
                    
                    // Now, for each pair, ensure the right player is on court for their starting position
                    const finalCourtPlayers = [...courtPlayers];
                    const finalBenchPlayers = [...benchPlayers];
                    
                    // Check each position and swap with bench partner if needed for optimal positioning
                    Object.keys(initialPositions).forEach(position => {
                        if (position === 'bench' || !initialPositions[position]) return;
                        
                        const currentPlayer = initialPositions[position];
                        const benchPartner = finalBenchPlayers.find(p => p.subPair === currentPlayer.id);
                        
                        if (benchPartner) {
                            const isBackRow = isBackRowPosition(position);
                            let shouldSwap = false;
                            
                            if (isBackRow) {
                                // Back row: prefer higher serve receive
                                shouldSwap = benchPartner.serveReceive > currentPlayer.serveReceive;
                            } else {
                                // Front row: prefer higher setting
                                shouldSwap = benchPartner.setting > currentPlayer.setting;
                            }
                            
                            if (shouldSwap) {
                                // Swap the players
                                const courtIndex = finalCourtPlayers.indexOf(currentPlayer);
                                const benchIndex = finalBenchPlayers.indexOf(benchPartner);
                                
                                if (courtIndex >= 0 && benchIndex >= 0) {
                                    finalCourtPlayers[courtIndex] = benchPartner;
                                    finalBenchPlayers[benchIndex] = currentPlayer;
                                    initialPositions[position] = benchPartner;
                                }
                            }
                        }
                    });
                    
                    setCourtPositions({
                        ...initialPositions,
                        bench: finalBenchPlayers
                    });
                }

                // Reset tracking
                setSubstitutionCount(0);
                setSubHistory([]);
                setRotationCount(0);
                setBestLineups([{ positions: { bench: benchPlayers }, score: 100 }]);

                setIsOptimizing(false);
            };
            
            // Modified shuffle function to cycle strategies  
            const shuffleSubstitutionalStrategy = () => {
                setOptimizationStrategy(prev => (prev + 1) % SUBSTITUTIONAL_STRATEGIES.length);
                // Re-run optimization with new strategy
                setTimeout(() => optimizeSubstitutionalPlay(), 100);
            };

            // FIXED: Rotation with automatic substitutions based on position requirements
            const rotateWithSubstitutions = (direction) => {
                let newPositions;
                
                if (direction === 'forward') {
                    newPositions = {
                        backRight: courtPositions.backMiddle,
                        frontRight: courtPositions.backRight,
                        frontMiddle: courtPositions.frontRight,
                        frontLeft: courtPositions.frontMiddle,
                        backLeft: courtPositions.frontLeft,
                        backMiddle: courtPositions.backLeft,
                        bench: [...courtPositions.bench]
                    };
                } else {
                    newPositions = {
                        frontLeft: courtPositions.backLeft,
                        frontMiddle: courtPositions.frontLeft,
                        frontRight: courtPositions.frontMiddle,
                        backRight: courtPositions.frontRight,
                        backMiddle: courtPositions.backRight,
                        backLeft: courtPositions.backMiddle,
                        bench: [...courtPositions.bench]
                    };
                }

                // Check for required substitutions after rotation
                const substitutions = [];
                Object.keys(newPositions).forEach(position => {
                if (position === 'bench') return;
                
                const currentPlayer = newPositions[position];
                if (!currentPlayer || !currentPlayer.subPair) return;
                
                const partner = players.find(p => p.id === currentPlayer.subPair);
                if (!partner) return;
                
                const isBackRow = isBackRowPosition(position);
                
                // Enhanced logic: Ensure fair play by alternating players based on position needs
                let shouldSubstitute;
                
                if (isBackRow) {
                    // Back row: substitute if partner has better OR EQUAL serve receive (fair play)
                    shouldSubstitute = partner.serveReceive >= currentPlayer.serveReceive;
                } else {
                    // Front row: Always substitute unless current player has better setting AND better/equal SR
                    if (currentPlayer.setting > partner.setting && currentPlayer.serveReceive >= partner.serveReceive) {
                        // Current player is clearly better suited for front row - keep them
                        shouldSubstitute = false;
                    } else if (partner.setting > currentPlayer.setting) {
                        // Partner has better setting - substitute them in
                        shouldSubstitute = true;
                    } else {
                        // Equal or mixed skills - ensure fair play by checking who played back row
                        // If current player has better SR, they should have played back row, so substitute them out for fair play
                        shouldSubstitute = currentPlayer.serveReceive >= partner.serveReceive;
                    }
                }
                
                if (shouldSubstitute && newPositions.bench.includes(partner)) {
                    let reason;
                    if (isBackRow) {
                        reason = partner.serveReceive > currentPlayer.serveReceive ? 'Better SR for back row' : 'Fair play rotation';
                    } else {
                        if (partner.setting > currentPlayer.setting) {
                            reason = 'Better setting for front row';
                        } else if (currentPlayer.serveReceive >= partner.serveReceive) {
                            reason = 'Fair play rotation';
                        } else {
                            reason = 'Position rotation';
                        }
                    }
                            
                    substitutions.push({
                        position,
                        outPlayer: currentPlayer,
                        inPlayer: partner,
                        reason: reason
                    });
                }
            });

                // Apply substitutions
                substitutions.forEach(sub => {
                    newPositions[sub.position] = sub.inPlayer;
                    
                    // Remove incoming player from bench
                    const benchIndex = newPositions.bench.findIndex(p => p.id === sub.inPlayer.id);
                    if (benchIndex >= 0) {
                        newPositions.bench.splice(benchIndex, 1);
                    }
                    
                    // Add outgoing player to bench
                    newPositions.bench.push(sub.outPlayer);
                    
                    // Update tracking - add for forward, subtract for backward
                    if (direction === 'forward') {
                        setSubstitutionCount(prev => prev + 1);
                        setSubHistory(prev => [...prev, {
                            rotation: rotationCount + (direction === 'forward' ? 1 : -1),
                            out: sub.outPlayer.name,
                            in: sub.inPlayer.name,
                            reason: sub.reason
                        }]);
                    } else {
                        setSubstitutionCount(prev => Math.max(0, prev - 1));
                        setSubHistory(prev => prev.slice(0, -1)); // Remove last entry
                    }
                });

                setCourtPositions(newPositions);
setRotationCount(prev => direction === 'forward' ? prev + 1 : Math.max(0, prev - 1));
};

// Server swap function for substitutional mode
const swapServerWithPair = () => {
    if (playMode !== 'substitutional' || !courtPositions.backLeft) return;
    
    const currentServer = courtPositions.backLeft;
    if (!currentServer.subPair) return; // No pair to swap with
    
    const serverPartner = players.find(p => p.id === currentServer.subPair);
    if (!serverPartner) return;
    
    // Check if partner is on bench
    const partnerOnBench = courtPositions.bench.some(p => p.id === serverPartner.id);
    if (!partnerOnBench) return; // Partner not available for swap
    
    const newPositions = { ...courtPositions };
    
    // Swap server with their pair
    newPositions.backLeft = serverPartner;
    
    // Remove partner from bench and add current server to bench
    const benchIndex = newPositions.bench.findIndex(p => p.id === serverPartner.id);
    if (benchIndex >= 0) {
        newPositions.bench.splice(benchIndex, 1);
    }
    newPositions.bench.push(currentServer);
    
    setCourtPositions(newPositions);
    
    // Update substitution tracking
    setSubstitutionCount(prev => prev + 1);
    setSubHistory(prev => [...prev, {
        rotation: rotationCount,
        out: currentServer.name,
        in: serverPartner.name,
        reason: 'Server swap with pair'
    }]);
};
            
// Export team data
            const exportData = () => {
                const data = {
                    players,
                    teamName,
                    minThreshold,
                    courtPositions,
                    playMode,
                    teamSlots,
                    gameStats,
                    exportDate: new Date().toISOString()
                };
                
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `volleyball_team_${teamName.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
            };

            // Import team data
            const handleImportData = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        if (importedData.players) setPlayers(importedData.players);
                        if (importedData.teamName) setTeamName(importedData.teamName);
                        if (importedData.minThreshold) setMinThreshold(importedData.minThreshold);
                        if (importedData.courtPositions) setCourtPositions(importedData.courtPositions);
                        if (importedData.playMode) setPlayMode(importedData.playMode);
                        if (importedData.teamSlots) setTeamSlots(importedData.teamSlots);
                        if (importedData.gameStats) setGameStats(importedData.gameStats);
                        
                        alert('Team data imported successfully!');
                    } catch (error) {
                        alert('Error importing data. Please check the file format.');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            };

            // Helper function to check star player rules for rotational mode
            const checkStarRules = (positions) => {
                const courtPlayers = [
                    positions.backLeft,
                    positions.frontLeft,
                    positions.frontMiddle,
                    positions.frontRight,
                    positions.backRight,
                    positions.backMiddle
                ].filter(Boolean);

                const starsOnCourt = courtPlayers.filter(p => p.star).length;
                
                if (starsOnCourt === 0) return false;

                const starPositions = [];
                if (positions.backLeft?.star) starPositions.push(1);
                if (positions.frontLeft?.star) starPositions.push(2);
                if (positions.frontMiddle?.star) starPositions.push(3);
                if (positions.frontRight?.star) starPositions.push(4);
                if (positions.backRight?.star) starPositions.push(5);
                if (positions.backMiddle?.star) starPositions.push(6);

                for (let i = 0; i < starPositions.length; i++) {
                    for (let j = i + 1; j < starPositions.length; j++) {
                        const pos1 = starPositions[i];
                        const pos2 = starPositions[j];
                        
                        if (Math.abs(pos1 - pos2) === 1 || (pos1 === 1 && pos2 === 6) || (pos1 === 6 && pos2 === 1)) {
                            return false;
                        }
                    }
                }

                return true;
            };

           // Calculate rotation strengths for rotational mode
            const calculateRotationStrengths = (positions) => {
                const rotations = [];
                let currentPositions = { ...positions };
                
                for (let i = 0; i < 10; i++) {
                    const frontRowTotal = (currentPositions.frontLeft?.defense || 0) + 
                                         (currentPositions.frontMiddle?.defense || 0) + 
                                         (currentPositions.frontRight?.defense || 0);
                    const backRowTotal = (currentPositions.backLeft?.defense || 0) + 
                                        (currentPositions.backMiddle?.defense || 0) + 
                                        (currentPositions.backRight?.defense || 0);
                    
                    rotations.push({
                        frontRowTotal,
                        backRowTotal,
                        serverRating: currentPositions.backLeft?.serving || 0,
                        rotation: i
                    });
                    
                    const newPositions = {
                        backRight: currentPositions.backMiddle,
                        frontRight: currentPositions.backRight,
                        frontMiddle: currentPositions.frontRight,
                        frontLeft: currentPositions.frontMiddle,
                        backLeft: currentPositions.frontLeft,
                        bench: [...currentPositions.bench]
                    };
                    
                    const newBench = [...currentPositions.bench];
                    if (newBench.length > 0) {
                        newBench.push(currentPositions.backLeft);
                        newPositions.backMiddle = newBench.shift();
                    } else {
                        newPositions.backMiddle = currentPositions.backLeft;
                    }
                    newPositions.bench = newBench;
                    
                    currentPositions = newPositions;
                }
                
                return rotations;
            };

            // Serving Priority Optimization with Star Rules
            const optimizeServingPriority = async () => {
                if (playMode === 'substitutional') {
                    optimizeSubstitutionalPlay();
                    return;
                }

                setIsOptimizing(true);
                
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const activePlayers = players.filter(p => p.active);
                const starPlayers = activePlayers.filter(p => p.star);
                
                if (activePlayers.length < 6) {
                    setIsOptimizing(false);
                    return;
                }

                if (starPlayers.length === 0) {
                    alert("Please select at least 1 star player to use optimization.");
                    setIsOptimizing(false);
                    return;
                }

                let eligibleServers = starPlayers.filter(p => p.serving >= 3);
                if (eligibleServers.length === 0) {
                    eligibleServers = activePlayers.filter(p => p.serving >= 3);
                }
                if (eligibleServers.length === 0) {
                    eligibleServers = [...starPlayers].sort((a, b) => b.serving - a.serving).slice(0, 1);
                }
                
                const firstServer = eligibleServers.sort((a, b) => a.defense - b.defense)[0];
                const remainingPlayers = activePlayers.filter(p => p.id !== firstServer.id);
                const topServers = remainingPlayers.sort((a, b) => b.serving - a.serving).slice(0, 5);
                const benchPlayers = remainingPlayers.filter(p => !topServers.some(ts => ts.id === p.id))
                    .sort((a, b) => b.defense - a.defense);

                let allLineups = [];

                const generatePermutations = (arr, current = []) => {
                    if (current.length === arr.length) {
                        return [current];
                    }
                    const perms = [];
                    for (let i = 0; i < arr.length; i++) {
                        if (!current.includes(arr[i])) {
                            const newCurrent = [...current, arr[i]];
                            perms.push(...generatePermutations(arr, newCurrent));
                        }
                    }
                    return perms;
                };

                const serverPermutations = generatePermutations(topServers);

                for (const perm of serverPermutations) {
                    const testPositions = {
                        backLeft: firstServer,
                        frontLeft: perm[0],
                        frontMiddle: perm[1],
                        frontRight: perm[2],
                        backRight: perm[3],
                        backMiddle: perm[4],
                        bench: benchPlayers
                    };

                    if (!checkStarRules(testPositions)) continue;

                    const rotations = calculateRotationStrengths(testPositions);
                    
                    let aboveThresholdCount = 0;
                    let totalDefense = 0;
                    let servingScore = 0;
                    let starBonus = 0;

                    rotations.forEach((rotation, index) => {
                        if (rotation.frontRowTotal >= minThreshold && rotation.backRowTotal >= minThreshold) {
                            aboveThresholdCount++;
                        }
                        totalDefense += rotation.frontRowTotal + rotation.backRowTotal;
                        
                        const rotationWeight = Math.max(1, 20 - (index * 2));
                        servingScore += rotation.serverRating * rotationWeight;

                        let currentPos = { ...testPositions };
                        for (let r = 0; r < index; r++) {
                            const newPos = {
                                backRight: currentPos.backMiddle,
                                frontRight: currentPos.backRight,
                                frontMiddle: currentPos.frontRight,
                                frontLeft: currentPos.frontMiddle,
                                backLeft: currentPos.frontLeft,
                                bench: [...currentPos.bench]
                            };
                            const newBench = [...currentPos.bench];
                            if (newBench.length > 0) {
                                newBench.push(currentPos.backLeft);
                                newPos.backMiddle = newBench.shift();
                            } else {
                                newPos.backMiddle = currentPos.backLeft;
                            }
                            newPos.bench = newBench;
                            currentPos = newPos;
                        }

                        const courtPlayers = [currentPos.backLeft, currentPos.frontLeft, currentPos.frontMiddle,
                                            currentPos.frontRight, currentPos.backRight, currentPos.backMiddle];
                        const starsOnCourt = courtPlayers.filter(p => p && p.star).length;
                        if (starsOnCourt >= 2) starBonus += 3;
                    });

                    const avgDefense = totalDefense / rotations.length;
                    const thresholdPercent = aboveThresholdCount / rotations.length;
                    const score = (servingScore * 1.0) + (avgDefense * 2) + (thresholdPercent * 50) + starBonus;

                    allLineups.push({
                        positions: testPositions,
                        score: score,
                        thresholdPercent: thresholdPercent,
                        avgDefense: avgDefense,
                        servingScore: servingScore,
                        starBonus: starBonus
                    });
                }

                allLineups.sort((a, b) => b.score - a.score);
                const topLineups = allLineups.slice(0, 10);
                
                setBestLineups(topLineups);
                setCurrentLineupIndex(0);

                if (topLineups.length > 0) {
                    setCourtPositions(topLineups[0].positions);
                }
                
                setIsOptimizing(false);
            };
           const optimizeStandardPlay = async () => {
        setIsOptimizing(true);
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const activePlayers = players.filter(p => p.active);
        const starPlayers = activePlayers.filter(p => p.star);
        
        if (activePlayers.length < 6) {
            setIsOptimizing(false);
            return;
        }

        if (starPlayers.length === 0) {
            alert("Please select at least 1 star player to use optimization.");
            setIsOptimizing(false);
            return;
        }

        // Rank ALL active players by defense (with serving as tiebreaker)
        const rankedPlayers = [...activePlayers].sort((a, b) => {
            if (a.defense === b.defense) {
                return b.serving - a.serving;
            }
            return b.defense - a.defense;
        });

        // Create alternating pattern for full rotation
        // Pair: 1st with last, 2nd with 2nd-to-last, etc.
        const totalPlayers = rankedPlayers.length;
        const rotationOrder = [];
        
        // Build alternating pairs: high with low, with higher ranked ahead
        for (let i = 0; i < Math.floor(totalPlayers / 2); i++) {
            const highRanked = rankedPlayers[i];
            const lowRanked = rankedPlayers[totalPlayers - 1 - i];
            
            // Higher ranked player goes first in rotation
            rotationOrder.push(highRanked);
            rotationOrder.push(lowRanked);
        }
        
        // If odd number of players, add the middle player at the end
        if (totalPlayers % 2 === 1) {
            const middlePlayer = rankedPlayers[Math.floor(totalPlayers / 2)];
            rotationOrder.push(middlePlayer);
        }

        // Starting positions: first 6 from rotation order
        const startingPositions = {
            backLeft: rotationOrder[0],       // Server position
            frontLeft: rotationOrder[1],      
            frontMiddle: rotationOrder[2],    
            frontRight: rotationOrder[3],     
            backRight: rotationOrder[4],      
            backMiddle: rotationOrder[5],     
            bench: rotationOrder.slice(6)     // Rest on bench
        };
        // Check star player rules
        if (!checkStarRules(startingPositions)) {
            // Try different starting rotations to find valid star arrangement
            let validArrangement = null;
            
            for (let startOffset = 1; startOffset < Math.min(6, totalPlayers); startOffset++) {
                const testPositions = {
                    backLeft: rotationOrder[startOffset % totalPlayers],
                    frontLeft: rotationOrder[(startOffset + 1) % totalPlayers],
                    frontMiddle: rotationOrder[(startOffset + 2) % totalPlayers],
                    frontRight: rotationOrder[(startOffset + 3) % totalPlayers],
                    backRight: rotationOrder[(startOffset + 4) % totalPlayers],
                    backMiddle: rotationOrder[(startOffset + 5) % totalPlayers],
                    bench: [
                        ...rotationOrder.slice(0, startOffset),
                        ...rotationOrder.slice(startOffset + 6)
                    ]
                };
                
                if (checkStarRules(testPositions)) {
                    validArrangement = testPositions;
                    break;
                }
            }

            if (validArrangement) {
                setCourtPositions(validArrangement);
            } else {
                alert("Cannot find valid rotation that follows star player rules. Try adjusting star player positions.");
                setIsOptimizing(false);
                return;
            }
        } else {
            setCourtPositions(startingPositions);
        }

        // Verify rotation quality - check all possible 6-player combinations
        const finalLineup = startingPositions;
        const rotations = calculateRotationStrengths(finalLineup);
        
        let aboveThresholdCount = 0;
        let totalDefense = 0;
        let starBonus = 0;

        rotations.forEach((rotation, index) => {
            if (rotation.frontRowTotal >= minThreshold && rotation.backRowTotal >= minThreshold) {
                aboveThresholdCount++;
            }
            totalDefense += rotation.frontRowTotal + rotation.backRowTotal;

            // Star bonus calculation for current rotation
            let currentPos = { ...finalLineup };
            for (let r = 0; r < index; r++) {
                const newPos = {
                    backRight: currentPos.backMiddle,
                    frontRight: currentPos.backRight,
                    frontMiddle: currentPos.frontRight,
                    frontLeft: currentPos.frontMiddle,
                    backLeft: currentPos.frontLeft,
                    backMiddle: currentPos.backLeft,
                    bench: [...currentPos.bench]
                };
                
                // Handle bench rotation
                const newBench = [...currentPos.bench];
                if (newBench.length > 0) {
                    newBench.push(currentPos.backLeft);
                    newPos.backMiddle = newBench.shift();
                } else {
                    newPos.backMiddle = currentPos.backLeft;
                }
                newPos.bench = newBench;
                currentPos = newPos;
            }

            const courtPlayers = [currentPos.backLeft, currentPos.frontLeft, currentPos.frontMiddle,
                                currentPos.frontRight, currentPos.backRight, currentPos.backMiddle];
            const starsOnCourt = courtPlayers.filter(p => p && p.star).length;
            if (starsOnCourt >= 2) starBonus += 3;
        });

        const avgDefense = totalDefense / rotations.length;
        const thresholdPercent = aboveThresholdCount / rotations.length;
        const score = (avgDefense * 2) + (thresholdPercent * 50) + starBonus;

        const optimizedLineup = {
            positions: finalLineup,
            score: score,
            thresholdPercent: thresholdPercent,
            avgDefense: avgDefense,
            servingScore: 0,
            starBonus: starBonus
        };

        setBestLineups([optimizedLineup]);
        setCurrentLineupIndex(0);
        
        setIsOptimizing(false);
    };

            const shuffleStandardPlay = () => {
                if (bestLineups.length === 0) return;
                
                const nextIndex = (currentLineupIndex + 1) % bestLineups.length;
                setCurrentLineupIndex(nextIndex);
                setCourtPositions(bestLineups[nextIndex].positions);
            };

            const autoArrangePlayers = () => {
                const activePlayers = players.filter(p => p.active);
                if (activePlayers.length < 6) return;

                const newPositions = {
                    backLeft: activePlayers.find(p => p.name === '1') || activePlayers[0],
                    frontLeft: activePlayers.find(p => p.name === '2') || activePlayers[1],
                    frontMiddle: activePlayers.find(p => p.name === '3') || activePlayers[2],
                    frontRight: activePlayers.find(p => p.name === '4') || activePlayers[3],
                    backRight: activePlayers.find(p => p.name === '5') || activePlayers[4],
                    backMiddle: activePlayers.find(p => p.name === '6') || activePlayers[5],
                    bench: activePlayers.slice(6)
                };
                setCourtPositions(newPositions);
                
                // Reset substitution tracking
                if (playMode === 'substitutional') {
                    setSubstitutionCount(0);
                    setSubHistory([]);
                    setRotationCount(0);
                }
            };

            const rotateForward = () => {
                if (playMode === 'substitutional') {
                    rotateWithSubstitutions('forward');
                    return;
                }

                const courtPlayers = [
                    courtPositions.backLeft,
                    courtPositions.backMiddle,
                    courtPositions.backRight,
                    courtPositions.frontLeft,
                    courtPositions.frontMiddle,
                    courtPositions.frontRight
                ].filter(Boolean);
                
                if (courtPlayers.length < 6) return;

                const newPositions = {
                    backRight: courtPositions.backMiddle,
                    frontRight: courtPositions.backRight,
                    frontMiddle: courtPositions.frontRight,
                    frontLeft: courtPositions.frontMiddle,
                    backLeft: courtPositions.frontLeft,
                    bench: [...courtPositions.bench]
                };

                const newBench = [...courtPositions.bench];
                newBench.push(courtPositions.backLeft);
                
                if (newBench.length > 0) {
                    newPositions.backMiddle = newBench.shift();
                }
                
                newPositions.bench = newBench;
                setCourtPositions(newPositions);
            };

            const rotateBackward = () => {
                if (playMode === 'substitutional') {
                    rotateWithSubstitutions('backward');
                    return;
                }

                const courtPlayers = [
                    courtPositions.backLeft,
                    courtPositions.backMiddle,
                    courtPositions.backRight,
                    courtPositions.frontLeft,
                    courtPositions.frontMiddle,
                    courtPositions.frontRight
                ].filter(Boolean);
                
                if (courtPlayers.length < 6) return;

                const newPositions = {
                    frontLeft: courtPositions.backLeft,
                    frontMiddle: courtPositions.frontLeft,
                    frontRight: courtPositions.frontMiddle,
                    backRight: courtPositions.frontRight,
                    backMiddle: courtPositions.backRight,
                    bench: [...courtPositions.bench]
                };

                const newBench = [...courtPositions.bench];
                newBench.unshift(courtPositions.backMiddle);
                
                if (newBench.length > 0) {
                    newPositions.backLeft = newBench.pop();
                }
                
                newPositions.bench = newBench;
                setCourtPositions(newPositions);
            };
           // Drag and Drop handlers
            const handleDragStart = (e, player) => {
                if (gameMode) {
                    e.preventDefault();
                    return;
                }
                setDraggedPlayer(player);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDragEnter = (e, zone) => {
                e.preventDefault();
                setDropZone(zone);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                setDropZone(null);
            };

            const handleDrop = (e, targetPosition) => {
                e.preventDefault();
                if (!draggedPlayer || gameMode) return;

                const newPositions = { ...courtPositions };
                
                let currentPosition = null;
                Object.keys(newPositions).forEach(pos => {
                    if (pos === 'bench') {
                        const benchIndex = newPositions[pos].findIndex(p => p.id === draggedPlayer.id);
                        if (benchIndex >= 0) {
                            currentPosition = { type: 'bench', index: benchIndex };
                        }
                    } else if (newPositions[pos] && newPositions[pos].id === draggedPlayer.id) {
                        currentPosition = { type: 'court', position: pos };
                    }
                });

                if (currentPosition) {
                    if (currentPosition.type === 'bench') {
                        newPositions.bench.splice(currentPosition.index, 1);
                    } else {
                        newPositions[currentPosition.position] = null;
                    }
                }

                if (targetPosition === 'bench') {
                    newPositions.bench.push(draggedPlayer);
                } else if (targetPosition.startsWith('bench-')) {
                    const index = parseInt(targetPosition.split('-')[1]);
                    newPositions.bench.splice(index, 0, draggedPlayer);
                } else {
                    if (newPositions[targetPosition]) {
                        if (currentPosition && currentPosition.type === 'court') {
                            newPositions[currentPosition.position] = newPositions[targetPosition];
                        } else if (currentPosition && currentPosition.type === 'bench') {
                            newPositions.bench.splice(currentPosition.index, 0, newPositions[targetPosition]);
                        }
                    }
                    newPositions[targetPosition] = draggedPlayer;
                }

                setCourtPositions(newPositions);
                setDraggedPlayer(null);
                setDropZone(null);
            };
          // Calculate current strengths based on play mode
            const calculateCurrentStrengths = () => {
                if (playMode === 'rotational') {
                    return calculateRotationStrengths(courtPositions).slice(0, 6);
                } else {
                    // For substitutional mode, just calculate current position strengths without rotation simulation
                    const backRowSR = (courtPositions.backLeft?.serveReceive || 0) + 
                                     (courtPositions.backMiddle?.serveReceive || 0) + 
                                     (courtPositions.backRight?.serveReceive || 0);
                    
                    const frontRowSetting = (courtPositions.frontLeft?.setting || 0) + 
                                           (courtPositions.frontMiddle?.setting || 0) + 
                                           (courtPositions.frontRight?.setting || 0);
                    
                    return [{
                        backRowSR,
                        frontRowSetting,
                        serverRating: courtPositions.backLeft?.serving || 0,
                        rotation: 0
                    }];
                }
            };

            const currentStrengths = calculateCurrentStrengths();

            // Game Mode Stat Tile Component
            const GameStatTile = ({ player, position, isOnCourt, benchIndex }) => {
    const subColorClass = player.subColor !== null ? SUB_COLORS[player.subColor] : '';
    const isNoSub = (playMode === 'substitutional' && player.star) || player.isFullTime;

    const defenseSuccess = getPlayerGameStat(player.id, 'defense', 'success');
    const defenseMiss = getPlayerGameStat(player.id, 'defense', 'miss');
    const servingSuccess = getPlayerGameStat(player.id, 'serving', 'success');
    const servingMiss = getPlayerGameStat(player.id, 'serving', 'miss');

    return React.createElement('div', {
        className: `p-1 rounded-lg shadow-md transition-all ${
            isNoSub ? 'no-sub-player' : subColorClass
        } bg-blue-100 border-2 border-blue-500`,
        'data-player-id': player.id
    },
        React.createElement('div', { className: "text-center font-bold text-sm mb-1" }, player.name),
        React.createElement('div', { className: "text-xs text-center" },
    "D: ",
    React.createElement('span', { className: "text-green-600 font-medium" }, defenseSuccess),
    "/",
    React.createElement('span', { className: "text-red-600 font-medium" }, defenseMiss),
    " | S: ",
    React.createElement('span', { className: "text-green-600 font-medium" }, servingSuccess),
    "/",
    React.createElement('span', { className: "text-red-600 font-medium" }, servingMiss)
),
    
    );
};

            // Regular Player Tile Component (non-game mode)
            const PlayerTile = ({ player, position, isOnCourt, benchIndex }) => {
                const subColorClass = player.subColor !== null ? SUB_COLORS[player.subColor] : '';
                const isNoSub = (playMode === 'substitutional' && player.star) || player.isFullTime;
                
                return React.createElement('div', {
                    className: `p-3 rounded-lg shadow-md cursor-pointer transition-all ${
                        player.active 
                            ? (isOnCourt ? 'bg-blue-100 border-2 border-blue-500' : 'bg-green-100 border-2 border-green-400')
                            : 'bg-gray-200 border-2 border-gray-300'
                    } ${isNoSub ? 'no-sub-player' : subColorClass} ${
                        playMode === 'rotational' && player.star && !isNoSub ? 'star-player' : ''
                    } ${draggedPlayer && draggedPlayer.id === player.id ? 'dragging' : ''}`,
                    draggable: !gameMode,
                    onDragStart: (e) => handleDragStart(e, player),
                    onClick: () => handleEditPlayer(player)
                },
                    React.createElement('div', { className: "flex items-center justify-between" },
                        React.createElement('div', { className: "font-semibold text-sm" }, player.name),
                        React.createElement('div', { className: "flex gap-1" },
                            (playMode === 'rotational' && player.star && !gameMode) && React.createElement('span', { className: "text-yellow-500 text-xs" }, '⭐'),
                            (playMode === 'substitutional' && (player.star || player.isFullTime)) && React.createElement('span', { className: "text-yellow-500 text-xs" }, '⭐'),
                            (playMode === 'substitutional' && player.subPair) && React.createElement('span', { className: "text-blue-500 text-xs" }, '🔗')
                        )
                    ),
                    position && React.createElement('div', { className: "text-xs text-gray-600 mt-1" }, position)
                );
            };

            const DropZone = ({ position, currentPlayer, label }) => {
    const currentGame = getCurrentGameStats();
    const isGameLocked = currentGame?.locked || false;
    const isServer = position === 'backLeft';

    const handleStatClick = (category, type) => {
        if (isGameLocked || !currentPlayer) return;
        updatePlayerGameStat(currentPlayer.id, category, type);
        triggerStatAnimation(currentPlayer.id, position, type);
    };

    return React.createElement('div', { className: "relative" },
        // Top buttons (Defense +/- for all positions, Serving +/- for server position)
        gameMode && React.createElement('div', { className: "flex justify-center gap-1 mb-1" },
            React.createElement('button', {
    className: "w-6 h-6 bg-green-500 text-white rounded-full text-xs flex items-center justify-center",
    onClick: () => handleStatClick('defense', 'success'),
    disabled: isGameLocked || !currentPlayer,
    style: { opacity: isGameLocked || !currentPlayer ? 0.3 : 1 }
}, "+"),
React.createElement('button', {
    className: "w-6 h-6 bg-red-500 text-white rounded-full text-xs flex items-center justify-center",
    onClick: () => handleStatClick('defense', 'miss'),
    disabled: isGameLocked || !currentPlayer,
    style: { opacity: isGameLocked || !currentPlayer ? 0.3 : 1 }
}, "✗"),
            isServer && React.createElement('button', {
    className: "w-6 h-6 bg-green-500 text-white rounded-full text-xs flex items-center justify-center ml-2",
    onClick: () => handleStatClick('serving', 'success'),
    disabled: isGameLocked || !currentPlayer,
    style: { opacity: isGameLocked || !currentPlayer ? 0.3 : 1 }
}, "+"),
isServer && React.createElement('button', {
    className: "w-6 h-6 bg-red-500 text-white rounded-full text-xs flex items-center justify-center",
    onClick: () => handleStatClick('serving', 'miss'),
    disabled: isGameLocked || !currentPlayer,
    style: { opacity: isGameLocked || !currentPlayer ? 0.3 : 1 }
}, "✗")
        ),
        
        // Serving label for server position
        isServer && React.createElement('div', { className: "text-xs text-center text-orange-700 mb-1" }, "↑ Serving"),
        
        // Player tile area
        React.createElement('div', {
            className: `h-18 border-2 border-dashed rounded-lg flex items-center justify-center transition-all ${
                dropZone === position ? 'drop-zone-active' : 'border-gray-300'
            }`,
            onDragOver: handleDragOver,
            onDragEnter: (e) => handleDragEnter(e, position),
            onDragLeave: handleDragLeave,
            onDrop: (e) => handleDrop(e, position)
        },
            currentPlayer ? 
                (gameMode ? 
                    React.createElement(GameStatTile, { player: currentPlayer, position: label, isOnCourt: true }) :
                    React.createElement(PlayerTile, { player: currentPlayer, position: label, isOnCourt: true })
                ) :
                React.createElement('span', { className: "text-xs text-gray-400" }, "Empty")
        )
    );
};
        const CourtDisplay = () => {
                const currentGame = getCurrentGameStats();
                const isGameLocked = currentGame?.locked || false;
                
                return React.createElement('div', { className: "bg-orange-50 border-2 border-orange-300 rounded-lg p-4 mb-6" },
                    React.createElement('div', { className: "text-center text-sm font-semibold mb-4 text-orange-800" },
                        `${teamName} - Court Layout (${playMode.charAt(0).toUpperCase() + playMode.slice(1)} Mode)${gameMode ? ' - GAME MODE' : ''}`
                    ),
                    
                    // Game mode indicator and lock status
                    gameMode && React.createElement('div', { className: "mb-4 p-2 bg-blue-100 rounded-lg text-center" },
                        React.createElement('div', { className: "text-sm font-medium text-blue-800 mb-1" },
                            currentGame ? `Game ${currentGame.id} - ${currentGame.date}` : 'No Active Game'
                        ),
                        isGameLocked && React.createElement('div', { className: "text-xs text-yellow-700 font-medium" },
                            "🔒 Game Locked - Double tap to unlock"
                        )
                    ),
                    
                    // Substitution Counter for substitutional mode
                    playMode === 'substitutional' && !gameMode && (
                        React.createElement('div', { className: "mb-4 p-2 substitution-counter text-center text-sm" },
                            `Substitutions: ${substitutionCount} | Rotations: ${rotationCount}`
                        )
                    ),
                    
                    // Current rotation strengths (only in non-game mode)
                    !gameMode && currentStrengths.length > 0 && (
                        React.createElement('div', { className: "mb-4 p-3 bg-white rounded-lg border" },
                            React.createElement('div', { className: "text-xs font-semibold mb-2 text-center" }, 
                                playMode === 'rotational' 
                                    ? `Row Totals (Defense) - Min: ${minThreshold}`
                                    : "Row Totals (SR: Serve Receive, Set: Setting)"
                            ),
                            React.createElement('div', { className: "flex justify-between text-xs mb-2" },
                                playMode === 'rotational' ? (
                                    React.createElement(React.Fragment, {},
                                        React.createElement('div', {}, 
                                            `Front: ${currentStrengths[0]?.frontRowTotal || 0}`,
                                            React.createElement('span', { 
                                                className: `ml-1 ${(currentStrengths[0]?.frontRowTotal || 0) >= minThreshold ? 'text-green-600' : 'text-red-600'}`
                                            }, (currentStrengths[0]?.frontRowTotal || 0) >= minThreshold ? '✓' : '✗')
                                        ),
                                        React.createElement('div', {}, 
                                            `Back: ${currentStrengths[0]?.backRowTotal || 0}`,
                                            React.createElement('span', { 
                                                className: `ml-1 ${(currentStrengths[0]?.backRowTotal || 0) >= minThreshold ? 'text-green-600' : 'text-red-600'}`
                                            }, (currentStrengths[0]?.backRowTotal || 0) >= minThreshold ? '✓' : '✗')
                                        )
                                    )
                                ) : (
                                    React.createElement(React.Fragment, {},
                                        React.createElement('div', {}, `Back SR: ${currentStrengths[0]?.backRowSR || 0}`),
                                        React.createElement('div', {}, `Front Set: ${currentStrengths[0]?.frontRowSetting || 0}`)
                                    )
                                )
                            ),
                            bestLineups.length > 0 && (
                                React.createElement('div', { className: "text-xs text-center text-gray-600" },
                                    `Lineup ${currentLineupIndex + 1} of ${bestLineups.length} best options`
                                )
                            )
                        )
                    ),

                    // Back Row (20 ft line)
                    React.createElement('div', { className: "border-b-2 border-dashed border-orange-400 pb-3 mb-3" },
                        React.createElement('div', { className: "text-xs text-center mb-2 text-orange-700" }, "Back Row (20 ft)"),
                        React.createElement('div', { className: "grid grid-cols-3 gap-2" },
    React.createElement('div', { className: "text-center" },
        React.createElement(DropZone, { 
            position: "backLeft", 
            currentPlayer: courtPositions.backLeft, 
            label: "BL" 
        })
    ),
    React.createElement('div', { className: "text-center" },
        React.createElement(DropZone, { 
            position: "backMiddle", 
            currentPlayer: courtPositions.backMiddle, 
            label: "BM" 
        })
    ),
    React.createElement('div', { className: "text-center" },
        React.createElement(DropZone, { 
            position: "backRight", 
            currentPlayer: courtPositions.backRight, 
            label: "BR" 
        })
    )
                        )
                    ),

                   // Front Row (10 ft line)
                    React.createElement('div', { className: "border-b-2 border-dashed border-orange-400 pb-3 mb-3" },
                        React.createElement('div', { className: "text-xs text-center mb-2 text-orange-700" }, "Front Row (10 ft)"),
                        React.createElement('div', { className: "grid grid-cols-3 gap-2" },
                          React.createElement('div', { className: "text-center" },
    React.createElement(DropZone, { 
        position: "frontLeft", 
        currentPlayer: courtPositions.frontLeft, 
        label: "FL" 
    })
),
React.createElement('div', { className: "text-center" },
    React.createElement(DropZone, { 
        position: "frontMiddle", 
        currentPlayer: courtPositions.frontMiddle, 
        label: "FM" 
    })
),
React.createElement('div', { className: "text-center" },
    React.createElement(DropZone, { 
        position: "frontRight", 
        currentPlayer: courtPositions.frontRight, 
        label: "FR" 
    })
)  
                        )
                    ),

                    // Net
                    React.createElement('div', { className: "w-full h-2 bg-black mb-4 rounded" }),

                    // Rotation Controls
React.createElement('div', { className: "flex justify-center gap-2 mb-4" },
    React.createElement('button', {
        onClick: rotateBackward,
        className: "flex items-center gap-2 px-3 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed text-sm",
        disabled: [courtPositions.backLeft, courtPositions.backMiddle, courtPositions.backRight, courtPositions.frontLeft, courtPositions.frontMiddle, courtPositions.frontRight].filter(Boolean).length < 6
    },
        "⟲ Previous"
    ),
    // Server swap button for substitutional mode
    playMode === 'substitutional' && courtPositions.backLeft && courtPositions.backLeft.subPair && courtPositions.bench.some(p => p.id === courtPositions.backLeft.subPair) && (
        React.createElement('button', {
            onClick: swapServerWithPair,
            className: "flex items-center gap-1 px-3 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition-colors text-sm",
            title: "Swap server with their substitution pair"
        },
            "⇄ Swap Server"
        )
    ),
    React.createElement('button', {
        onClick: rotateForward,
        className: "flex items-center gap-2 px-3 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed text-sm",
        disabled: [courtPositions.backLeft, courtPositions.backMiddle, courtPositions.backRight, courtPositions.frontLeft, courtPositions.frontMiddle, courtPositions.frontRight].filter(Boolean).length < 6
    },
        "Next ⟳"
    )
),

                    // Game Mode Lock/Unlock Controls and Undo
gameMode && currentGame && React.createElement('div', { className: "space-y-2 mt-4" },
    // Game name editing
    React.createElement('div', { className: "text-center" },
        React.createElement('input', {
            type: "text",
            value: currentGame.name || `Game ${currentGame.id}`,
            onChange: (e) => {
                const teamKey = teamSlots.active;
                setGameStats(prev => {
                    const updated = { ...prev };
                    const gameIndex = updated[teamKey].games.findIndex(g => g.id === currentGame.id);
                    if (gameIndex >= 0) {
                        updated[teamKey].games[gameIndex].name = e.target.value;
                        localStorage.setItem('volleyball_gameStats', JSON.stringify(updated));
                    }
                    return updated;
                });
            },
            className: "text-center text-sm font-medium bg-transparent border-b border-blue-300 focus:border-blue-500 outline-none px-2 py-1",
            disabled: isGameLocked
        })
    ),
    
    // Controls row
    React.createElement('div', { className: "flex justify-center gap-2" },
        // Undo button
        !isGameLocked && React.createElement('button', {
            onClick: undoLastAction,
            className: `px-3 py-2 rounded-lg transition-colors text-sm ${
                undoHistory.length > 0 
                    ? 'bg-orange-500 text-white hover:bg-orange-600' 
                    : 'bg-gray-300 text-gray-500 cursor-not-allowed'
            }`,
            disabled: undoHistory.length === 0,
            title: `Undo last action (${undoHistory.length} available)`
        }, `↶ Undo (${undoHistory.length})`),
        
        // Lock/Unlock button
        isGameLocked ? (
            React.createElement('button', {
                onClick: unlockCurrentGame,
                className: "px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 transition-colors text-sm",
                onDoubleClick: unlockCurrentGame
            }, "🔓 Double-tap to Unlock")
        ) : (
            React.createElement('button', {
                onClick: lockCurrentGame,
                className: "px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors text-sm"
            }, "🔒 Lock Game")
        )
    )
)
                );
            };

            const BenchDisplay = () => (
                React.createElement('div', { 
                    className: "bg-green-50 border-2 border-green-300 rounded-lg p-4 mb-6",
                    onDragOver: !gameMode ? handleDragOver : undefined,
                    onDragEnter: !gameMode ? (e) => handleDragEnter(e, 'bench') : undefined,
                    onDragLeave: !gameMode ? handleDragLeave : undefined,
                    onDrop: !gameMode ? (e) => handleDrop(e, 'bench') : undefined
                },
                    React.createElement('div', { className: "text-center text-sm font-semibold mb-3 text-green-800" },
    gameMode ? "Bench Players (Tap stat bubbles to track)" :
    playMode === 'substitutional' 
        ? "Bench Players (Available for substitution)"
        : "Bench Players (Next to rotate in at top)"
),
                    React.createElement('div', { className: "space-y-2" },
                        courtPositions.bench.map((player, index) => (
                            React.createElement('div', { key: player.id, className: "flex items-center gap-2" },
                                !gameMode && React.createElement('span', { className: "text-xs w-6 text-center" }, 
    playMode === 'rotational' ? index + 1 : index + 1
),
                                gameMode ? 
                                    React.createElement(GameStatTile, { player: player, isOnCourt: false, benchIndex: index }) :
                                    React.createElement(PlayerTile, { player: player, isOnCourt: false, benchIndex: index })
                            )
                        )),
                        courtPositions.bench.length === 0 && (
                            React.createElement('div', { className: "text-center text-gray-500 text-sm" }, "No bench players")
                        )
                    ),

                    // Team Totals (Game Mode Only)
                    gameMode && React.createElement('div', { className: "mt-4 p-3 bg-white rounded-lg border" },
                        React.createElement('div', { className: "text-sm font-semibold mb-2 text-center" }, "Team Totals"),
                        React.createElement('div', { className: "grid grid-cols-2 gap-4 text-xs" },
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "font-medium" }, "Defense"),
                                React.createElement('div', { className: "text-green-600" }, `✓ ${getTeamTotals('defense', 'success')}`),
                                React.createElement('div', { className: "text-red-600" }, `✗ ${getTeamTotals('defense', 'miss')}`)
                            ),
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "font-medium" }, "Serving"),
                                React.createElement('div', { className: "text-green-600" }, `✓ ${getTeamTotals('serving', 'success')}`),
                                React.createElement('div', { className: "text-red-600" }, `✗ ${getTeamTotals('serving', 'miss')}`)
                            )
                        )
                    )
                )
            );
            // Game History Browser Component
const GameHistoryBrowser = () => {
    const gameHistory = getGameHistory();
    
    if (!showGameHistory) return null;
    
    return React.createElement('div', { className: "mb-6 bg-gray-50 border rounded-lg p-4" },
        React.createElement('div', { className: "flex items-center justify-between mb-4" },
            React.createElement('h3', { className: "text-lg font-semibold" }, 
                `${teamName} - Game History (${gameHistory.length} games)`
            ),
            React.createElement('button', {
                onClick: () => {
                    setShowGameHistory(false);
                    setSelectedHistoryGame(null);
                },
                className: "text-gray-500 hover:text-gray-700"
            }, "✕")
        ),
        
        selectedHistoryGame ? (
            // Individual Game View
            React.createElement('div', {},
                React.createElement('div', { className: "flex items-center justify-between mb-4" },
    React.createElement('button', {
        onClick: () => setSelectedHistoryGame(null),
        className: "flex items-center gap-2 text-blue-600 hover:text-blue-800"
    }, "← Back to Game List"),
    React.createElement('div', { className: "flex items-center gap-2" },
        React.createElement('h4', { className: "text-md font-semibold" }, 
            selectedHistoryGame.name || `Game ${selectedHistoryGame.id}`
        ),
        React.createElement('button', {
            onClick: (e) => {
                e.stopPropagation();
                deleteGame(selectedHistoryGame.id);
            },
            className: "w-8 h-8 bg-red-500 text-white rounded-full text-xs flex items-center justify-center hover:bg-red-600 transition-colors",
            title: "Delete game"
        }, "×")
    )
),
                
                // Game stats display
                React.createElement('div', { className: "space-y-4" },
                    // Team totals
                    React.createElement('div', { className: "p-3 bg-white rounded-lg border" },
                        React.createElement('div', { className: "text-sm font-semibold mb-2 text-center" }, "Team Totals"),
                        React.createElement('div', { className: "grid grid-cols-2 gap-4 text-xs" },
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "font-medium" }, "Defense"),
                                React.createElement('div', { className: "text-green-600" }, 
                                    `✓ ${getGameTotalsForGame(selectedHistoryGame.id, 'defense', 'success')}`
                                ),
                                React.createElement('div', { className: "text-red-600" }, 
                                    `✗ ${getGameTotalsForGame(selectedHistoryGame.id, 'defense', 'miss')}`
                                )
                            ),
                            React.createElement('div', { className: "text-center" },
                                React.createElement('div', { className: "font-medium" }, "Serving"),
                                React.createElement('div', { className: "text-green-600" }, 
                                    `✓ ${getGameTotalsForGame(selectedHistoryGame.id, 'serving', 'success')}`
                                ),
                                React.createElement('div', { className: "text-red-600" }, 
                                    `✗ ${getGameTotalsForGame(selectedHistoryGame.id, 'serving', 'miss')}`
                                )
                            )
                        )
                    ),
                    
                    // Individual player stats
                    React.createElement('div', { className: "p-3 bg-white rounded-lg border" },
                        React.createElement('div', { className: "text-sm font-semibold mb-3 text-center" }, "Player Statistics"),
                        React.createElement('div', { className: "space-y-2" },
                            players.filter(p => p.active).map(player => {
                                const stats = getPlayerStatsForGame(selectedHistoryGame.id, player.id);
                                const hasStats = stats.defense.success + stats.defense.miss + stats.serving.success + stats.serving.miss > 0;
                                
                                if (!hasStats) return null;
                                
                                return React.createElement('div', { 
                                    key: player.id,
                                    className: "flex items-center justify-between p-2 bg-gray-50 rounded"
                                },
                                    React.createElement('div', { className: "font-medium text-sm" }, player.name),
                                    React.createElement('div', { className: "text-xs" },
                                        `D: ${stats.defense.success}/${stats.defense.miss} | S: ${stats.serving.success}/${stats.serving.miss}`
                                    )
                                );
                            })
                        )
                    )
                )
            )
        ) : (
            // Game List View
            gameHistory.length === 0 ? (
                React.createElement('div', { className: "text-center text-gray-500 py-8" },
                    "No completed games found. Lock a game to add it to history."
                )
            ) : (
                React.createElement('div', { className: "space-y-2" },
                    gameHistory.map(game => (
                     React.createElement('div', {
    key: game.id,
    className: "p-3 bg-white border rounded-lg hover:bg-gray-50 transition-colors"
},
    React.createElement('div', { className: "flex items-center justify-between" },
        React.createElement('div', { 
            className: "flex-1 cursor-pointer",
            onClick: () => setSelectedHistoryGame(game)
        },
            React.createElement('div', { className: "font-medium text-sm" }, 
                game.name || `Game ${game.id}`
            ),
            React.createElement('div', { className: "text-xs text-gray-500" }, 
                `Date: ${game.date}`
            ),
            React.createElement('div', { className: "text-xs text-gray-600 mt-1" },
                `D: ${getGameTotalsForGame(game.id, 'defense', 'success')}/${getGameTotalsForGame(game.id, 'defense', 'miss')} | `,
                `S: ${getGameTotalsForGame(game.id, 'serving', 'success')}/${getGameTotalsForGame(game.id, 'serving', 'miss')}`
            )
        ),
        React.createElement('button', {
            onClick: (e) => {
                e.stopPropagation();
                deleteGame(game.id);
            },
            className: "ml-3 w-8 h-8 bg-red-500 text-white rounded-full text-xs flex items-center justify-center hover:bg-red-600 transition-colors",
            title: "Delete game"
        }, "×")
    )
)   
                    ))
                )
            )
        )
    );
};
           return React.createElement('div', { className: "max-w-md mx-auto bg-white min-h-screen p-4" },
                // PWA Install Prompt
                showInstallPrompt && (
                    React.createElement('div', { className: "install-prompt mb-4 p-4 text-white rounded-lg flex items-center justify-between" },
                        React.createElement('div', {},
                            React.createElement('div', { className: "font-semibold text-sm" }, "Install Volleyball App"),
                            React.createElement('div', { className: "text-xs opacity-90" }, "Add to home screen for offline use")
                        ),
                        React.createElement('div', { className: "flex gap-2" },
                            React.createElement('button', {
                                onClick: () => setShowInstallPrompt(false),
                                className: "px-3 py-1 bg-white bg-opacity-20 rounded text-xs"
                            }, "Later"),
                            React.createElement('button', {
                                onClick: handleInstallClick,
                                className: "px-3 py-1 bg-white text-purple-600 rounded text-xs font-semibold"
                            }, "Install")
                        )
                    )
                ),

                // Header with game mode toggle or team switcher
                React.createElement('div', { className: "mb-6" },
                    React.createElement('div', { className: "flex items-center justify-between mb-2" },
                        React.createElement('input', {
                            type: "text",
                            value: teamName,
                            onChange: (e) => setTeamName(e.target.value),
                            className: "text-lg font-bold bg-transparent border-b-2 border-gray-300 focus:border-blue-500 outline-none",
                            disabled: gameMode
                        }),
                     React.createElement('div', { className: "flex gap-2" },
    React.createElement('button', { 
        onClick: exportData,
        className: "p-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600",
        title: "Export team data",
        disabled: gameMode
    }, "💾"),
    React.createElement('label', { 
        className: `p-2 bg-green-500 text-white rounded-lg hover:bg-green-600 cursor-pointer ${gameMode ? 'opacity-50 cursor-not-allowed' : ''}`,
        title: "Import team data"
    },
        "📂",
        !gameMode && React.createElement('input', {
            type: "file",
            accept: ".json",
            onChange: handleImportData,
            className: "hidden"
        })
    )
)  
                    ),
                    
                  // Game Mode Toggle or Team Switcher
gameMode ? (
    React.createElement('div', { className: "flex gap-2" },
        React.createElement('button', {
            onClick: toggleGameMode,
            className: "flex-1 py-2 px-3 rounded text-sm font-medium bg-red-500 text-white hover:bg-red-600"
        }, "Exit Game Mode"),
        React.createElement('button', {
            onClick: startNewGame,
            className: "flex-1 py-2 px-3 rounded text-sm font-medium bg-green-500 text-white hover:bg-green-600"
        }, "New Game")
    )
) : (
    React.createElement('div', { className: "space-y-2" },
        React.createElement('div', { className: "flex gap-2" },
            ['team1', 'team2', 'team3'].filter(slot => slot !== teamSlots.active).map(slot => (
                React.createElement('button', {
                    key: slot,
                    onClick: () => switchTeam(slot),
                    className: `flex-1 py-2 px-3 rounded text-sm font-medium transition-colors bg-gray-100 border border-gray-300 text-gray-700 hover:bg-gray-200`
                }, teamSlots[slot].name)
            ))
        ),
        React.createElement('button', {
            onClick: () => setShowGameHistory(!showGameHistory),
            className: `w-full py-2 px-3 rounded text-sm font-medium transition-colors ${
                showGameHistory ? 'bg-purple-600 text-white' : 'bg-purple-100 text-purple-700 hover:bg-purple-200'
            }`,
            title: "View game history"
        }, showGameHistory ? "Hide Game History" : "📊 View Game History")
    )
)  
                ),

                // Add Game History Browser here (move it to this location)
React.createElement(GameHistoryBrowser),
                                      
              // Play Mode Toggle (hidden in game mode)
                !gameMode && React.createElement('div', { className: "mb-4 p-3 bg-gray-50 rounded-lg" },
                    React.createElement('div', { className: "text-sm font-medium mb-2" }, "Play Mode"),
                    React.createElement('div', { className: "flex gap-2" },
                        React.createElement('button', {
                            onClick: () => setPlayMode('rotational'),
                            className: `flex-1 py-2 px-3 rounded text-sm font-medium transition-colors ${
                                playMode === 'rotational' 
                                    ? 'bg-blue-500 text-white' 
                                    : 'bg-white border border-gray-300 text-gray-700 hover:bg-gray-50'
                            }`
                        }, "Rotational"),
                        React.createElement('button', {
                            onClick: () => setPlayMode('substitutional'),
                            className: `flex-1 py-2 px-3 rounded text-sm font-medium transition-colors ${
                                playMode === 'substitutional' 
                                    ? 'bg-green-500 text-white' 
                                    : 'bg-white border border-gray-300 text-gray-700 hover:bg-gray-50'
                            }`
                        }, "Substitutional")
                    )
                ),

                // Game Mode Entry Button (only show when not in game mode)
                !gameMode && React.createElement('div', { className: "mb-4 p-3 bg-purple-50 border border-purple-200 rounded-lg" },
                    React.createElement('div', { className: "text-center" },
                        React.createElement('button', {
                            onClick: toggleGameMode,
                            className: "w-full py-3 px-4 bg-purple-600 text-white rounded-lg hover:bg-purple-700 font-medium transition-colors",
                            disabled: players.filter(p => p.active).length < 6
                        }, "🎮 Enter Game Mode"),
                        React.createElement('div', { className: "text-xs text-purple-700 mt-2" },
                            "Track live game statistics with tap-to-score"
                        )
                    )
                ),

                // Mode-specific info panel (hidden in game mode)
                !gameMode && (playMode === 'rotational' ? (
                    React.createElement('div', { className: "mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg" },
                        React.createElement('div', { className: "text-sm font-medium text-yellow-800 mb-1" },
                            `Star Players: ${players.filter(p => p.star).length}/3`
                        ),
                        React.createElement('div', { className: "text-xs text-yellow-700" },
                            "⭐ Select up to 3 star players for rotational optimization. Algorithms ensure 1+ star always on court and prevent adjacent positioning."
                        )
                    )
               ) : (
    React.createElement('div', { className: "mb-4 space-y-2" },
        React.createElement('div', { className: "p-3 bg-green-50 border border-green-200 rounded-lg" },
            React.createElement('div', { className: "text-sm font-medium text-green-800 mb-1" },
                "Substitutional Play Mode"
            ),
            React.createElement('div', { className: "text-xs text-green-700 mb-2" },
                "⭐ Gold tiles = no substitution partner. Matching colors = paired for substitutions."
            ),
            React.createElement('div', { className: "text-xs text-green-600" },
                `No-Sub Players: ${players.filter(p => p.star || p.isFullTime).length} | Sub Pairs: ${Math.floor(players.filter(p => p.subPair).length / 2)}`
            )
        ),
        React.createElement('div', { className: "p-2 bg-blue-50 border border-blue-200 rounded-lg" },
            React.createElement('div', { className: "text-sm font-medium text-blue-800 text-center" },
                `Strategy ${optimizationStrategy + 1}: ${SUBSTITUTIONAL_STRATEGIES[optimizationStrategy].name}`
            ),
            React.createElement('div', { className: "text-xs text-blue-600 text-center mt-1" },
                SUBSTITUTIONAL_STRATEGIES[optimizationStrategy].description
            )
        )
    )
)),

                // Court Display
                React.createElement(CourtDisplay),
                                      
                // Bench Display
                React.createElement(BenchDisplay),

                // Optimization Controls (hidden in game mode)
                !gameMode && React.createElement('div', { className: "mb-4 p-4 bg-gray-50 rounded-lg" },
                    playMode === 'rotational' && (
                        React.createElement('div', { className: "mb-3" },
                            React.createElement('label', { className: "block text-sm font-medium mb-1" }, 
                                `Minimum Row Total: ${minThreshold}`
                            ),
                            React.createElement('input', {
                                type: "range",
                                min: "3",
                                max: "15",
                                value: minThreshold,
                                onChange: (e) => setMinThreshold(parseInt(e.target.value)),
                                className: "w-full"
                            }),
                            React.createElement('div', { className: "flex justify-between text-xs text-gray-500 mt-1" },
                                React.createElement('span', {}, "3"),
                                React.createElement('span', {}, "15")
                            )
                        )
                    ),
                    React.createElement('div', { className: "flex gap-2" },
                        React.createElement('button', {
                            onClick: playMode === 'rotational' ? optimizeStandardPlay : optimizeSubstitutionalPlay,
                            className: `flex-1 p-3 text-white rounded-lg transition-colors ${
                                isOptimizing ? 'optimizing cursor-not-allowed' : 
                                playMode === 'rotational' ? 'bg-purple-500 hover:bg-purple-600' : 'bg-green-500 hover:bg-green-600'
                            }`,
                            disabled: isOptimizing || players.filter(p => p.active).length < 6
                        },
                            isOptimizing ? "Optimizing..." : 
                            playMode === 'rotational' ? "🎯 Standard Play" : "🎯 Optimize Subs"
                        ),
                        playMode === 'rotational' && (
                            React.createElement('button', {
                                onClick: optimizeServingPriority,
                                className: `flex-1 p-3 text-white rounded-lg transition-colors ${
                                    isOptimizing ? 'optimizing cursor-not-allowed' : 'bg-orange-500 hover:bg-orange-600'
                                }`,
                                disabled: isOptimizing || players.filter(p => p.active).length < 6
                            },
                                isOptimizing ? "Optimizing..." : "⚡ Serving Priority"
                            )
                        ),
                       React.createElement('button', {
                            onClick: playMode === 'substitutional' ? shuffleSubstitutionalStrategy : shuffleStandardPlay,
                            className: "px-3 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors disabled:bg-gray-400",
                            disabled: playMode === 'substitutional' ? players.filter(p => p.active).length < 6 : bestLineups.length === 0,
                            title: playMode === 'substitutional' ? "Switch optimization strategy" : "Shuffle through best lineups"
                        },
                            "🔀"
                        )
                    ),
                    React.createElement('div', { className: "flex gap-2 mt-2" },
                        React.createElement('button', {
                            onClick: playMode === 'substitutional' ? () => {
                                // Reset substitutional mode
                                const resetPlayers = players.map(p => ({
                                    ...p,
                                    subPair: null,
                                    subColor: null,
                                    isFullTime: false
                                }));
                                setPlayers(resetPlayers);
                                setCourtPositions({
                                    backLeft: null,
                                    frontLeft: null,
                                    frontMiddle: null,
                                    frontRight: null,
                                    backRight: null,
                                    backMiddle: null,
                                    bench: []
                                });
                                setBestLineups([]);
                                setCurrentLineupIndex(0);
                                setSubstitutionCount(0);
                                setSubHistory([]);
                                setRotationCount(0);
                            } : autoArrangePlayers,
                            className: `${playMode === 'substitutional' ? 'flex-1' : 'flex-1'} p-3 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition-colors`,
                            disabled: playMode === 'rotational' && players.filter(p => p.active).length < 6
                        },
                            playMode === 'substitutional' ? "🔄 Reset" : "📋 Basic Setup"
                        ),
                        
                        // Manual Setup button for substitutional mode
                        playMode === 'substitutional' && (
                         React.createElement('button', {
    onClick: () => {
        const activePlayers = players.filter(p => p.active);
        if (activePlayers.length < 4) return; // Allow as few as 4 players
        
        // Separate players into categories based on existing user setup
        const unpairedPlayers = activePlayers.filter(p => p.star || p.isFullTime || !p.subPair);
        const pairedPlayers = activePlayers.filter(p => p.subPair && !p.star && !p.isFullTime);
        
        // Build court lineup respecting user's manual setup
        const courtPlayers = [];
        const benchPlayers = [];
        
        // Add all unpaired (no-sub) players to court first
        courtPlayers.push(...unpairedPlayers);
        
        // Process pairs - choose best player for starting position
        const processedPairs = new Set();
        
        pairedPlayers.forEach(player => {
            if (processedPairs.has(player.id)) return;
            
            const partner = players.find(p => p.id === player.subPair);
            if (partner && !processedPairs.has(partner.id)) {
                processedPairs.add(player.id);
                processedPairs.add(partner.id);
                
                // For pairs, select better all-around player to start
                // (will be optimized by position later)
                if (player.allAround >= partner.allAround) {
                    if (courtPlayers.length < 6) {
                        courtPlayers.push(player);
                        benchPlayers.push(partner);
                    } else {
                        benchPlayers.push(player, partner);
                    }
                } else {
                    if (courtPlayers.length < 6) {
                        courtPlayers.push(partner);
                        benchPlayers.push(player);
                    } else {
                        benchPlayers.push(player, partner);
                    }
                }
            }
        });
        
        // Use optimized court positioning if we have players
        if (courtPlayers.length >= 4) {
            let finalPositions;
            
            if (courtPlayers.length >= 6) {
                // Full team - use the same optimization as Optimize Subs
                finalPositions = optimizeCourtPositions(courtPlayers, unpairedPlayers);
                
                // Apply position-based swapping with bench partners
                Object.keys(finalPositions).forEach(position => {
                    if (position === 'bench' || !finalPositions[position]) return;
                    
                    const currentPlayer = finalPositions[position];
                    const benchPartner = benchPlayers.find(p => p.subPair === currentPlayer.id);
                    
                    if (benchPartner) {
                        const isBackRow = isBackRowPosition(position);
                        let shouldSwap = false;
                        
                        if (isBackRow) {
                            shouldSwap = benchPartner.serveReceive > currentPlayer.serveReceive;
                        } else {
                            shouldSwap = benchPartner.setting > currentPlayer.setting;
                        }
                        
                        if (shouldSwap) {
                            const courtIndex = courtPlayers.indexOf(currentPlayer);
                            const benchIndex = benchPlayers.indexOf(benchPartner);
                            
                            if (courtIndex >= 0 && benchIndex >= 0) {
                                courtPlayers[courtIndex] = benchPartner;
                                benchPlayers[benchIndex] = currentPlayer;
                                finalPositions[position] = benchPartner;
                            }
                        }
                    }
                });
            } else {
                // Partial team (4-5 players) - basic positioning
                const sortedBySR = [...courtPlayers].sort((a, b) => b.serveReceive - a.serveReceive);
                
                finalPositions = {
                    backLeft: sortedBySR[0] || null,
                    backMiddle: sortedBySR[1] || null,
                    backRight: courtPlayers.length > 2 ? sortedBySR[2] : null,
                    frontLeft: courtPlayers.length > 3 ? sortedBySR[3] : null,
                    frontMiddle: courtPlayers.length > 4 ? sortedBySR[4] : null,
                    frontRight: courtPlayers.length > 5 ? sortedBySR[5] : null
                };
            }
            
            setCourtPositions({
                ...finalPositions,
                bench: benchPlayers
            });
            
            setSubstitutionCount(0);
            setSubHistory([]);
            setRotationCount(0);
        }
    },
    className: "flex-1 p-3 bg-cyan-500 text-white rounded-lg hover:bg-cyan-600 transition-colors",
    disabled: players.filter(p => p.active).length < 4
},
    "⚙️ Manual Setup"
)   
                        )
                    )
                ),
             // Players List (hidden in game mode or show with cumulative stats)
                React.createElement('div', { className: "mb-6" },
                    React.createElement('div', { className: "flex items-center justify-between mb-3" },
                        React.createElement('h2', { className: "text-lg font-semibold" }, 
                            gameMode ? "Season Stats" : `Team Roster (${players.filter(p => p.active).length} active / ${players.length} total)`
                        ),
                        !gameMode && React.createElement('button', {
                            onClick: () => setShowPlayerForm(true),
                            className: "flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
                        },
                            "+ Add Player"
                        )
                    ),
                    
                    React.createElement('div', { className: "space-y-2" },
                        players.map(player => {
                            const subColorClass = player.subColor !== null ? SUB_COLORS[player.subColor] : '';
                            const isNoSub = (playMode === 'substitutional' && player.star) || player.isFullTime;
                            const subPartner = player.subPair ? players.find(p => p.id === player.subPair) : null;
                            
                            // Calculate cumulative stats
                            const cumulativeDefenseSuccess = getCumulativeStats(player.id, 'defense', 'success');
                            const cumulativeDefenseMiss = getCumulativeStats(player.id, 'defense', 'miss');
                            const cumulativeServingSuccess = getCumulativeStats(player.id, 'serving', 'success');
                            const cumulativeServingMiss = getCumulativeStats(player.id, 'serving', 'miss');
                            
                            return React.createElement('div', { 
                                key: player.id, 
                                className: `flex items-center gap-2 p-2 rounded-lg transition-all ${
    !gameMode && (isNoSub ? 'no-sub-player' : subColorClass || 'bg-white')
} ${!player.active ? 'opacity-50 bg-gray-100 border border-gray-300' : ''} ${gameMode ? 'bg-gray-50 border' : ''}`
                            },
                                !gameMode && React.createElement('button', {
                                    onClick: () => togglePlayerActive(player.id),
                                    className: `w-4 h-4 rounded border-2 ${
                                        player.active ? 'bg-green-500 border-green-500' : 'border-gray-300'
                                    }`
                                }),
                                !gameMode && React.createElement('button', {
                                    onClick: () => togglePlayerStar(player.id),
                                    className: `w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                                        player.star ? 'bg-yellow-400 border-yellow-500' : 'border-gray-300 hover:border-yellow-400'
                                    }`,
                                    title: playMode === 'rotational' ? 'Star Player' : 'No Substitution Partner'
                                },
                                    React.createElement('span', { className: "text-xs" }, 
                                        player.star ? '⭐' : '☆'
                                    )
                                ),
                                React.createElement('div', { 
                                    className: `flex-1 ${!gameMode ? 'cursor-pointer' : ''}`,
                                    onClick: !gameMode ? () => handleEditPlayer(player) : undefined
                                },
                                    React.createElement('div', { className: "flex items-center justify-between" },
                                        React.createElement('div', { className: `font-semibold text-sm ${!player.active ? 'text-gray-500' : ''}` }, 
    player.name + (!player.active ? ' (Inactive)' : '')
),
                                        React.createElement('div', { className: "flex gap-1" },
                                            !gameMode && subPartner && React.createElement('span', { 
                                                className: "text-xs text-blue-600",
                                                title: `Paired with ${subPartner.name}`
                                            }, '🔗'),
                                            !gameMode && player.isFullTime && React.createElement('span', { 
                                                className: "text-xs text-yellow-600",
                                                title: "Full-time player (no substitutions)"
                                            }, '⭐')
                                        )
                                    ),
                                    gameMode ? (
                                        // Show cumulative stats in game mode
                                        React.createElement('div', { className: "cumulative-stats mt-1" },
                                            `Season: D(${cumulativeDefenseSuccess}/${cumulativeDefenseMiss}) S(${cumulativeServingSuccess}/${cumulativeServingMiss})`
                                        )
                                    ) : (
                                        React.createElement('div', { className: "text-xs text-gray-600" },
                                            playMode === 'rotational' 
                                                ? `D:${player.defense} S:${player.serving}`
                                                : `S:${player.serving} SR:${player.serveReceive} Set:${player.setting} AA:${player.allAround}`
                                        )
                                    )
                                ),
                                !gameMode && playMode === 'substitutional' && (
                                    React.createElement('div', { className: "flex gap-1" },
                                        // Color change buttons for sub pairs
                                        !isNoSub && player.subPair && SUB_COLORS.map((colorClass, index) => (
                                            React.createElement('button', {
                                                key: index,
                                                onClick: () => changeSubColor(player.id, index),
                                                className: `w-4 h-4 rounded border ${colorClass} ${
                                                    player.subColor === index ? 'border-2 border-black' : 'border-gray-400'
                                                }`,
                                                title: `Change to color ${index + 1}`
                                            })
                                        )),
                                        // Unpair button
                                        !isNoSub && player.subPair && (
                                            React.createElement('button', {
                                                onClick: () => removeSubPair(player.id),
                                                className: "w-4 h-4 bg-red-500 text-white rounded text-xs flex items-center justify-center",
                                                title: "Remove substitution pairing"
                                            }, "×")
                                        )
                                    )
                                )
                            );
                        })
                    )
                ),

              // Enhanced Player Form Modal with mode-specific attributes (hidden in game mode)
                !gameMode && showPlayerForm && (
                    React.createElement('div', { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" },
                        React.createElement('div', { className: "bg-white rounded-lg p-6 w-80 mx-4 max-h-screen overflow-y-auto" },
                            React.createElement('h3', { className: "text-lg font-semibold mb-4" },
                                editingPlayer ? 'Edit Player' : 'Add New Player'
                            ),
                            
                            React.createElement('div', { className: "space-y-4" },
                                React.createElement('div', {},
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Player Name"),
                                    React.createElement('input', {
                                        type: "text",
                                        value: playerForm.name,
                                        onChange: (e) => setPlayerForm({...playerForm, name: e.target.value}),
                                        className: "w-full p-2 border rounded-lg focus:ring-2 focus:ring-blue-500 outline-none",
                                        placeholder: "Enter player name"
                                    })
                                ),
                                
                                // Defense Rating - Only show in rotational mode
                                playMode === 'rotational' && React.createElement('div', {},
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Defense (1-5)"),
                                    React.createElement('input', {
                                        type: "range",
                                        min: "1",
                                        max: "5",
                                        value: playerForm.defense,
                                        onChange: (e) => setPlayerForm({...playerForm, defense: parseInt(e.target.value)}),
                                        className: "w-full"
                                    }),
                                    React.createElement('div', { className: "text-center font-semibold text-sm" }, playerForm.defense)
                                ),
                                
                                // Serving Rating
                                React.createElement('div', {},
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Serving (1-5)"),
                                    React.createElement('input', {
                                        type: "range",
                                        min: "1",
                                        max: "5",
                                        value: playerForm.serving,
                                        onChange: (e) => setPlayerForm({...playerForm, serving: parseInt(e.target.value)}),
                                        className: "w-full"
                                    }),
                                    React.createElement('div', { className: "text-center font-semibold text-sm" }, playerForm.serving)
                                ),

                                // Serve Receive Rating - Only show in substitutional mode
                                playMode === 'substitutional' && React.createElement('div', {},
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Serve Receive - SR (1-5)"),
                                    React.createElement('input', {
                                        type: "range",
                                        min: "1",
                                        max: "5",
                                        value: playerForm.serveReceive,
                                        onChange: (e) => setPlayerForm({...playerForm, serveReceive: parseInt(e.target.value)}),
                                        className: "w-full"
                                    }),
                                    React.createElement('div', { className: "text-center font-semibold text-sm" }, playerForm.serveReceive)
                                ),

                                // Setting Rating - Only show in substitutional mode
                                playMode === 'substitutional' && React.createElement('div', {},
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "Setting (1-5)"),
                                    React.createElement('input', {
                                        type: "range",
                                        min: "1",
                                        max: "5",
                                        value: playerForm.setting,
                                        onChange: (e) => setPlayerForm({...playerForm, setting: parseInt(e.target.value)}),
                                        className: "w-full"
                                    }),
                                    React.createElement('div', { className: "text-center font-semibold text-sm" }, playerForm.setting)
                                ),

                                // All Around Rating - Only show in substitutional mode
                                playMode === 'substitutional' && React.createElement('div', {},
                                    React.createElement('label', { className: "block text-sm font-medium mb-1" }, "All Around (1-5)"),
                                    React.createElement('input', {
                                        type: "range",
                                        min: "1",
                                        max: "5",
                                        value: playerForm.allAround,
                                        onChange: (e) => setPlayerForm({...playerForm, allAround: parseInt(e.target.value)}),
                                        className: "w-full"
                                    }),
                                    React.createElement('div', { className: "text-center font-semibold text-sm" }, playerForm.allAround)
                                ),

                                // Star Player / No Sub Toggle
                                React.createElement('div', { className: "flex items-center gap-2" },
                                    React.createElement('label', { className: "block text-sm font-medium" }, 
                                        playMode === 'rotational' ? 'Star Player' : 'No Substitution Partner'
                                    ),
                                    React.createElement('button', {
                                        onClick: () => setPlayerForm({...playerForm, star: !playerForm.star}),
                                        className: `w-6 h-6 rounded-full border-2 flex items-center justify-center ${
                                            playerForm.star ? 'bg-yellow-400 border-yellow-500' : 'border-gray-300 hover:border-yellow-400'
                                        }`,
                                        type: "button"
                                    },
                                        React.createElement('span', { className: "text-xs" }, 
                                            playerForm.star ? '⭐' : '☆'
                                        )
                                    )
                                )
                            ),
                            
                            React.createElement('div', { className: "flex gap-3 mt-6" },
                                React.createElement('button', {
                                    onClick: () => {
                                        setShowPlayerForm(false);
                                        setEditingPlayer(null);
                                        setPlayerForm({ 
                                            name: '', 
                                            defense: 3, 
                                            serving: 3, 
                                            serveReceive: 3, 
                                            setting: 3, 
                                            allAround: 3, 
                                            active: true, 
                                            star: false 
                                        });
                                    },
                                    className: "flex-1 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50"
                                }, "Cancel"),
                                React.createElement('button', {
                                    onClick: editingPlayer ? handleUpdatePlayer : handleAddPlayer,
                                    className: "flex-1 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600",
                                    disabled: !playerForm.name.trim()
                                }, editingPlayer ? 'Update Player' : 'Add Player')
                            )
                        )
                    )
                ),

                // Enhanced Substitution History Panel (hidden in game mode)
                !gameMode && playMode === 'substitutional' && subHistory.length > 0 && (
                    React.createElement('div', { className: "mb-6 p-3 bg-blue-50 border border-blue-200 rounded-lg" },
                        React.createElement('h3', { className: "text-sm font-semibold mb-2 text-blue-800" }, "Recent Substitutions"),
                        React.createElement('div', { className: "space-y-1 max-h-32 overflow-y-auto" },
                            subHistory.slice(-5).map((sub, index) => (
                                React.createElement('div', { key: index, className: "text-xs text-blue-700" },
                                    `R${sub.rotation}: ${sub.out} → ${sub.in} (${sub.reason})`
                                )
                            ))
                        ),
                        React.createElement('button', {
                            onClick: () => {
                                setSubHistory([]);
                                setSubstitutionCount(0);
                                setRotationCount(0);
                            },
                            className: "mt-2 text-xs text-blue-600 hover:text-blue-800"
                        }, "Clear History")
                    )
                ),

                // Enhanced Drag-and-Drop Sub Pairing Tool (hidden in game mode)
                !gameMode && playMode === 'substitutional' && (
                    React.createElement('div', { className: "mb-6 p-3 bg-purple-50 border border-purple-200 rounded-lg" },
                        React.createElement('h3', { className: "text-sm font-semibold mb-2 text-purple-800" }, "Substitution Management"),
                        React.createElement('div', { className: "text-xs text-purple-700 mb-2" },
                            "Drag unpaired players onto each other to create pairs. Hold and drag pairs to delete icon to unlink."
                        ),
                        
                        // Show current pairing status
                        React.createElement('div', { className: "mb-3" },
                            React.createElement('div', { className: "text-xs font-medium text-purple-800 mb-1" }, "Current Status:"),
                            React.createElement('div', { className: "text-xs text-purple-700" },
                                `${players.filter(p => p.star || p.isFullTime).length} No-Sub Players | ${Math.floor(players.filter(p => p.subPair).length / 2)} Sub Pairs | ${players.filter(p => p.active && !p.star && !p.isFullTime && !p.subPair).length} Unpaired`
                            )
                        ),

                        // Current pairs display
                        Math.floor(players.filter(p => p.subPair).length / 2) > 0 && (
                            React.createElement('div', { className: "mb-3" },
                                React.createElement('div', { className: "text-xs font-medium text-purple-800 mb-2" }, "Linked Pairs:"),
                                React.createElement('div', { className: "flex gap-2 flex-wrap" },
                                    // Get unique pairs
                                    players.filter(p => p.subPair && p.id < p.subPair).map(player1 => {
                                        const player2 = players.find(p => p.id === player1.subPair);
                                        if (!player2) return null;
                                        
                                        const subColorClass = player1.subColor !== null ? SUB_COLORS[player1.subColor] : '';
                                        
                                        return React.createElement('div', {
                                            key: `pair-${player1.id}-${player2.id}`,
                                            className: `flex items-center gap-1 p-2 rounded-lg border-2 transition-all ${subColorClass} ${
                                                draggedPlayer && (draggedPlayer.id === player1.id || draggedPlayer.id === player2.id) ? 'opacity-50 scale-95' : ''
                                            }`,
                                        },
                                            React.createElement('div', { className: "text-xs font-medium" }, player1.name),
                                            React.createElement('div', { className: "text-blue-500 text-xs" }, '🔗'),
                                            React.createElement('div', { className: "text-xs font-medium" }, player2.name),
                                            React.createElement('button', {
                                                onClick: (e) => {
                                                    e.stopPropagation();
                                                    removeSubPair(player1.id);
                                                },
                                                className: "ml-2 w-5 h-5 bg-red-500 text-white rounded-full text-xs flex items-center justify-center hover:bg-red-600",
                                                title: "Unlink pair"
                                            }, "×")
                                        );
                                    }).filter(Boolean)
                                )
                            )
                        ),
                        
                        // Unpaired players for drag-and-drop pairing
                        players.filter(p => p.active && !p.star && !p.isFullTime && !p.subPair).length > 0 && (
                            React.createElement('div', {},
                                React.createElement('div', { className: "text-xs font-medium text-purple-800 mb-2" }, "Unpaired Players (drag onto each other to pair):"),
                                React.createElement('div', { className: "flex gap-2 flex-wrap" },
                                    players.filter(p => p.active && !p.star && !p.isFullTime && !p.subPair).map(player => (
                                        React.createElement('div', {
                                            key: player.id,
                                            className: `p-2 bg-white border-2 border-purple-300 rounded-lg text-xs font-medium cursor-move transition-all hover:bg-purple-50 ${
                                                draggedPlayer && draggedPlayer.id === player.id ? 'opacity-50 scale-95' : ''
                                            } ${dropZone === `pair-${player.id}` ? 'border-blue-500 bg-blue-50' : ''}`,
                                            draggable: true,
                                            onDragStart: (e) => {
                                                setDraggedPlayer(player);
                                                e.dataTransfer.effectAllowed = 'move';
                                            },
                                            onDragEnd: () => setDraggedPlayer(null),
                                            onDragOver: (e) => e.preventDefault(),
                                            onDragEnter: (e) => {
                                                e.preventDefault();
                                                if (draggedPlayer && draggedPlayer.id !== player.id && !draggedPlayer.subPair && !player.subPair) {
                                                    setDropZone(`pair-${player.id}`);
                                                }
                                            },
                                            onDragLeave: (e) => {
                                                e.preventDefault();
                                                setDropZone(null);
                                            },
                                            onDrop: (e) => {
                                                e.preventDefault();
                                                setDropZone(null);
                                                if (draggedPlayer && draggedPlayer.id !== player.id && !draggedPlayer.subPair && !player.subPair) {
                                                    createSubPair(draggedPlayer.id, player.id);
                                                    setDraggedPlayer(null);
                                                }
                                            }
                                        },
                                            player.name
                                        )
                                    ))
                                )
                            )
                        ),
                        
                        players.filter(p => p.active && !p.star && !p.isFullTime && !p.subPair).length === 0 && Math.floor(players.filter(p => p.subPair).length / 2) === 0 && (
                            React.createElement('div', { className: "text-xs text-gray-500" }, "All eligible players are paired or designated as no-sub.")
                        )
                    )
                )
            );
        };

        ReactDOM.render(React.createElement(VolleyballApp), document.getElementById('root'));
    </script>
</body>
</html>
